\documentclass[a4paper,10pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage[table,dvipsnames]{xcolor}
\usepackage{setup}
\usepackage[T1]{fontenc}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{inconsolata}
%\usepackage{libertine}
\usepackage{hyperref}
\usepackage{bbold}
% Add biblatex
\usepackage[style=alphabetic,backend=biber]{biblatex}
\addbibresource{biblio.bib}

\usepackage{calc}


\DeclareMathOperator{\kwdefmt}{\textsf{defmodtype}}
\DeclareMathOperator{\kwend}{\textsf{end}}
\DeclareMathOperator{\kwdo}{\textsf{do}}
\DeclareMathOperator{\kwbvr}{\textsf{\$behaviour}}
\DeclareMathOperator{\kwlet}{\textsf{let}}
\DeclareMathOperator{\kwin}{\textsf{in}}
\DeclareMathOperator{\kwprm}{\textsf{\$param}}
\DeclareMathOperator{\kwdefm}{\textsf{defmodule}}
\DeclareMathOperator{\kwopq}{\textsf{\$opaque}}
\DeclareMathOperator{\kwtp}{\textsf{\$type}}
\DeclareMathOperator{\kwpr}{\textsf{\$private}}
\DeclareMathOperator{\kwmdl}{\textsf{\$module}}
\DeclareMathOperator{\kwclbk}{\textsf{\$callback}}
\DeclareMathOperator{\kwfn}{\textsf{fn}}
\DeclareMathOperator{\kwlike}{\textsf{like}}
\DeclareMathOperator{\kwbeha}{\textsf{behaviour\!\_\!of}}
\DeclareMathOperator{\kwint}{\textsf{int}}
\DeclareMathOperator{\struct}{\textsf{struct}}
\DeclareMathOperator{\dom}{\textsf{dom}}
\newcommand{\tx}{\text{\rm x}}
\newcommand{\ty}{\text{\rm y}}
\newcommand{\BX}{\ensuremath{\mathcal{X}}}
\newcommand{\BY}{\ensuremath{\mathcal{Y}}}
\newcommand{\BH}[1]{\langle #1\rangle}
\newcommand{\self}{\texttt{\_\_MODULE\_\_}}

\author{Aghilas Y. Boussaa and Giuseppe Castagna}
\sloppy
\begin{document}


\section{Introduction}
\beppe{Cut and paste from the Programming paper Appendix}


GenServer is a behaviour of Elixir standard library that abstracts the
common client-server interaction. It provides the boilerplate to
supervise sync and async calls. The documentation of the latest
version (v1.15.6) can be found at \url{https://hexdocs.pm/elixir/1.15.6/GenServer.html}.

A schematic description of its definition (written using Typespec)
is given next, where we use colors to highlight the
interesting parts
%\pagebreak
\begin{minted}[escapeinside=!!,fontsize=\footnotesize,baselinestretch=.9]{elixir}
defmodule GenServer do
 # Types  
 @type !\color{typeAqua}option()! :: {:debug, debug()} | {:name, name()} | ...    !\color{typeAqua}//transparent\label{001}!
 @type !\color{typeAqua}result()! :: {:reply, reply(), state()} | ...             !\color{typeAqua}//transparent\label{002}!
 @type !\color{typeBlue}state()! :: term()                                        !\color{typeBlue}//opaque\label{003}!
 @type !\color{bordeaux}request()! :: term()                                      !\color{bordeaux}//parameter\label{004}!
 @type !\color{bordeaux}reply()! :: term()                                        !\color{bordeaux}//parameter\label{005}!
    !\etc!
 # Callbacks
 @callback init(init_arg :: term()) :: {:ok, state()} | :error 
 @optional_callback handle_call(request(),pid(),state()) :: result() 
 @optional_callback handle_cast(request(),state()) :: result()       
    !\etc!
 # Functions
 @spec start(!{\color{red}module()}!, any(), options()) :: on_start()          !\color{red}//higher-order\negspace\label{009}!
 def start(Mod, arg, opt) do
    !\etc!
end
\end{minted}
Let us make some observations for each section:
\begin{itemize}
  \item \textbf{Types.} The types \elix{option()} and \elix{result()} are completely defined and  shared by all implementations of the GenServer behaviour, thus they must be transparently exported. The type \elix{state()} is the type of internal state of a server and can be manipulated only by the functions of each implementation, thus it must be opaquely exported. The types \elix{request()} and \elix{reply()} describe the messages sent for requests and replies; as for \elix{state()}, they are specific to each implementation, but they must be public so that processes can perform correct requests; therefore they are parameter of the implementations.

  \item \textbf{Callbacks.} Callbacks are either mandatory or optional. From a typing point of view this is akin to the optional and mandatory fields for map types.

  \item \textbf{Functions.} The first argument of the \elix{start} function must be a module, but in practice it cannot be any module: it must be the same module that implements the behaviour or, at least (to type-check), a module implementing exactly the same behaviour.
\end{itemize}
What do these observations imply on the definition of types? If
behaviours are to be promoted to (module) types, then we expect the
GenServer behaviour to be defined as follows (we use a mock-up syntax
combined with our types):
\begin{minted}[escapeinside=!!,fontsize=\footnotesize,baselinestretch=.9]{elixir}
defmodule !\negspace\textbf{\color{darkgreen}type}! GenServer(!{\color{bordeaux}request, reply}!) do
 # Types
 !\textcolor{typeGreen}{type}! option() = {:debug, debug()} | {:name, name()} | ...      !\color{typeAqua}//transparent!
 !\textcolor{typeGreen}{type}! result() = {:reply, !{\color{bordeaux}reply}!, state()} | ...                 !\color{typeAqua}//transparent!
 !\textcolor{typeGreen}{type}! state()                                                   !\color{typeBlue}//opaque!
    !{\etc}!
 # Callbacks
 !\textcolor{typeGreen}{callback}! init :: init_arg() -> {:ok, state()} | :error      
 !\textcolor{typeGreen}{callback}! optional(handle_call) :: !{\color{bordeaux}request}!, pid(), state() -> result() 
 !\textcolor{typeGreen}{callback}! optional(handle_cast) :: !{\color{bordeaux}request}!, state() -> result()        
    !\etc!
 # Functions
 !\textcolor{typeGreen}{spec}! start :: GenServer(!{\color{bordeaux}request, reply}!), init_arg(), options() -> on_start()!\negspace!
    !\etc!
end
\end{minted}
The types \elix{request} and \elix{reply} are now parameters of the (module) type GenServer; the types \elix{request()} and \elix{reply()} are transparently exported, while \elix{state()} is opaque. optional callbacks are explicitly declared with a syntax reminiscent of map types. Finally, the type of the  first \elix{start} function explicitly declares that the first argument of the  function must be a module of the same type as the one implemented. Notice that the second argument of \elix{start} is of type \elix{init_arg()} since this argument is then passed to the function \elix{init}. We left the definition of \elix{init_arg()} unspecified, but it should probably be yet another parameter of the GenServer behaviour, exactly as  \elix{request()} and \elix{reply()}.  



\subsection{The PoETS Proposal}
In the paper "Principles of Elixir Type System"~\cite{CDV24}, we proposed to type the Genserver example as follows

\begin{minted}[escapeinside=!!,fontsize=\footnotesize]{elixir}
defmodule!\textbf{\color{red}type}! GenServer do  !\elabel{genservertypebegin} !                     
  # Types
  !\textcolor{bordeaux}{\$param}! request
  !\textcolor{bordeaux}{\$param}! reply
  !\textcolor{typeGreen}{\$type}! option = {:debug, debug()} | {:name, name()} | ...        !\color{typeAqua}//transparent!
  !\textcolor{typeGreen}{\$type}! result = {:reply, !{\color{bordeaux}reply}!, state()} | ...                   !\color{typeAqua}//transparent!
  !\textcolor{typeGreen}{\$opaque}! state                                                   !\color{typeBlue}//opaque!
    !{\etc}!
  # Callbacks
  !\textcolor{typeGreen}{\$callback}! init : init_arg() -> {:ok, state} | :error      
  !\textcolor{typeGreen}{\$callback}! optional(handle_call) : !{\color{bordeaux}request}!, pid(), state -> result
  !\textcolor{typeGreen}{\$callback}! optional(handle_cast) : !{\color{bordeaux}request}!, state -> result        
    !{\etc}!
end !\elabel{genservertypeend} !

defmodule GenServer do !\elabel{genserverbegin} !                     
  # Functions
  !\textcolor{typeGreen}{\$}! (Mod : GenServer[!{\color{bordeaux}request=a, reply=b}!],  arg : init_arg(), opt : Mod.options) -> on_start() !\elabel{starttype}!
    when a: term(), b: term()
  def start(Mod, arg, opt) do
    !\etc!
end !\elabel{genserverend}!
\end{minted}
Our current proposal that we describe in the rest of this document is very similar to the above, but much more detailed and formalized.

\section{The new Elixir module system}
An Elixir program is a sequence of module definitions. When a module definition contain a \elix{@callback} declaration, this module is considered a \emph{behaviour}. Behaviours are a kind of hybrid definitions since they define both a module type and, whenever they export functions, a module value. This ambiguity is resolved by the Elixir compiler, which will generate a module \emph{type} definition for the behaviour, and a module \emph{value} definition for the implementations exported by the behaviour.

So for example the definition of the \elix{GenServer} behaviour above will generate both a module type definition for the module type \elix{GenServer} (lines \ref{genservertypebegin}--\ref{genservertypeend}), and a module value definition for the module \elix{GenServer} exporting the functions defined in the behaviour (e.g., \elix{start/3}) (lines \ref{genserverbegin}--\ref{genserverend}).

For the sake of simplicity, we will suppose that this distinction is already done in the program. In the rest of the document, then, we will suppose that a program is a sequence of module type definitions, followed by the \texttt{Main} module definition, containing just a list of bindings. 
\[\overline{\kwdefmt \BX \kwdo \overline{P}\, \overline{D} \kwend}\kwdefm \textit{Main} \kwdo \overline{B} \kwend\]
\beppe{Guillaume suggests: $\overline{\kwdefmt \BX \kwdo \overline{P}\, \overline{D} \kwend} \overline{B}$}

Intuitively, the list of bindings $\overline{B}$ exported by the module \textit{Main} will be the list of the toplevel modules definitions of the program, whose general form is as follows: 
\begin{equation}\label{eq:module}
\kwdefm X \kwdo \overline{P}\, \overline{S}\, \overline{B} \kwend
\end{equation}
With this convention, every module defined in the program is then denoted by a unique path starting with \texttt{Main} module name.

The full syntax of the surface language is given in Figure \ref{fig:surfacesyntax}. In Elixir there is a unique syntactic category for names, although developers are invited to follow the naming convention of using capitalized names for modules and (thus) behaviours. To enhance clarity, we use $x$ to range over expression variables, $X$ for module names, $\tx$ for type names, and $\BX$ for behaviour names. 


\begin{figure}
  \begin{tabular}{r c ll}
    $\mathcal B$ & ::= &$\kwdefmt \BX\kwdo \overline{P}\, \overline{D} \kwend$ \\
    $N$ & ::= & $x$ \\
    & | & $X$ \\
    $S$ & ::= & $\kwbvr \BX$ \\
    $P$ &::= & \textcolor{Cerulean}{$\kwprm \tx$} \\
    $B$ &::= & $\kwdefm X \kwdo \textcolor{Cerulean}{\overline{P}}\, \overline{S}\, \overline{B} \kwend$ \\
    & | & $x = v$\\
    & | & $\kwpr x = v$ \\
    & | & $\kwtp \tx = t$ \\
    & | & \textcolor{Cerulean}{$\kwopq \tx = t$} \\
    $M$ & ::= & $X\textcolor{Cerulean}{[\,\overline{\tx=t}\,]}$ \\ 
    & | & $X.M$ & \text{\small JosÃ© version: only the last module of the path can be instantiated}\\
        & | & $\textcolor{Cerulean}{M}.M$ & \text{\small More general version: every module of the path can be instantiated}\\
$E$ &::= & $v$ \\
    & | & $x$ \\
    & | & $\kwlet N = E\kwin E$ \\
    & | & $E(\overline{E})$ \\
    & | & $\texttt{\%}\!\left\{\overline{\ell=E}\right\}$ \\
    & | & $E.\ell$ \\
    & | & $(E\in t)?E:E$ \\
    & | & $\textcolor{OrangeRed}{M.x}$ \\
    & | & $\textcolor{OrangeRed}{M}$ \\
     & | & $\textcolor{OrangeRed}{\self}$ \\
   $v$ & ::= & $c$ \\
    & | & $\texttt{\%}\!\left\{\overline{\ell=v}\right\}$ \\
    & | & $\$\bigwedge \overline{(\,\overline{\,t\,}\,)\rightarrow t} \kwfn \overline{x} \rightarrow E$ \\
    & | & \textcolor{OrangeRed}{$\$\bigcap \overline{\left(\overline{N:T}\right)\rightarrow T} \kwfn \overline{N}\rightarrow E$} \\
    $T$ & ::= & $t$ \\
    & | & $\left(\overline{N:T}\right)\rightarrow T$ \\
  %  & | & $[\overline{\tx:\star}]\to T$ & do we want this syntax or remove it and have $\left\{\overline P;\overline{S};\overline{D}\right\}$?\\
    & | & $\left\{\textcolor{Cerulean}{\overline{P}};\overline{S};\overline{D}\right\}$ & the programmer should be able to denote this type only via \textsf{like($M$)}\\
    $t$ & ::= & \texttt{:}k & singleton atom type\\
    & | & \texttt{atom()} & top atom type \\
    & | & $\texttt{\textcolor{OrangeRed}{module()}}$ & top module type \\
    & | & $(\overline{\,t\,})\rightarrow t$\\
    & | & $\texttt{\%}\!\left\{\texttt{..., }\overline{f}\right\}$ & open record type\\
    & | & $\texttt{\%}\!\left\{\overline{f}\right\}$ & closed record type \\
    & | & $t\vee t$ \\
    & | & $t\wedge t$ \\
    & | & $\neg t$\\
    & | & $\alpha$ \\
    & | & $\mathbb{O}$ \\
    & | & $\textcolor{OrangeRed}{M.\tx}$ \\
    & | & $\textcolor{OrangeRed}{\BX[\,\overline{\tx=t}\,]}$ \\ %& shall we move this into $T$? Consequence no $\kwtp x = \elix{Stack}$ [which seems ok]
    & | & \textcolor{Gray}{$\langle M\rangle$} & singleton type of M (modulo path equivalence)
 \\
    $f$ & ::= & $\ell : t$ & mandatory field \\%{\color{bordeaux}[should we use $T$ instead of $t$? Or $\BX[\overline{\tx=t}]$? Or $\{\overline{D}\}_{\overline{\BX}}$?]}\\
    & | & $\ell \;\texttt{=>}\; t$ & optional field\\ %{\color{bordeaux}[same questions as above]}\\
    $D$ & ::= & $\kwmdl X : T$ \\
    & | & $\kwclbk x : \bigcap \overline{T}$ \\
    & | & $\kwopq \tx$ \\
    & | & $\kwtp \tx = t$\\
  \end{tabular}

  \bigskip
  In \textcolor{Cerulean}{blue} the modifications of the  current Elixir syntax.
  \caption{Syntax of the surface language }\label{fig:surfacesyntax}
\end{figure}


\subsection{Module Types}
Let us first examine the syntax of the module types declarations, which is given by the syntax, \[\kwdefmt \BX\kwdo \overline{P}\, \overline{D} \kwend\] and which correspond to the definition of a behaviour (ie., a module with callback declarations), stripped of its function definitions (i.e., no \elix{def} or \elix{defp} definitions). The module type $\BX$ is defined by a list of type parameters $\overline{P}$, and a list of (type or module) export declarations and callback declarations $\overline{D}$. Every module implementing the behaviour $\BX$ must \emph{at least} provide:
\begin{itemize}
    \item a transparent type definition of the form $\kwtp \tx = t$ for every $\kwprm \tx$ declared in $\overline{P}$,
    \item an opaque type definition of the form $\kwopq \tx = t$ for every $\kwopq \tx$ declared in $\overline{D}$,
    \item repeat the transparent type definition of the form $\kwtp \tx = t$ for every $\kwtp \tx = t$ declared in $\overline{D}$,
    \item a definition of the form $x = v$  with $v$ of type $\bigcap\overline{T}$ for every callback $\kwclbk x : \bigcap \overline{T}$ declared in $\overline{D}$.
\end{itemize} 
For instance, a \elix{StackB} behaviour for modules wanting to implement a stack parametric in the type of its elements can be defined as follows:
\begin{minted}{elixir}
!\color{blue}defmodtype! StackB do
  !\tp!param elem
  !\tp!opaque stack
  !\tp!callback new : () -> stack
  !\tp!callback push : (stack, elem) -> stack
  !\tp!callback pop : stack -> {elem, stack}
end
\end{minted}

\subsection{Expressions}
In Figure~\ref{fig:surfacesyntax} we specified a minimal set of expressions---ranged over by $E$---to represent Elixir. The syntax is kept minimal since we want to focus on the module system. So our expressions form a simple functional language with records (in Elixir parlance ``maps'') and a type-case expression (in lieu of more general case expressions).  Elixir uses the notation $\texttt{\%}\!\left\{\overline{\ell=E}\right\}$ for records (maps) with fields $\ell$ initialized to $E$, and we reproduce it here faithfully. For type-cases we use instead the expression $(E\in t)?E_1:E_2$ which evaluates to $E_1$ or to $E_2$ according to whether $E$ returns a value of type $t$ or not; this is not valid Elixir syntax, but it serves a similar purpose. The syntax is essentially the one by~\cite{CDV24} with three notable additions (in red in the figure) to extend expressions to modules: $M$, denoting the module (reached by the path) $M$, \self{} which returns the name of the (innermost) current module, and $M.x$ denoting the function or constant $x$ exported by the module $M$. The other expressions are standard, though their syntax may not be familiar to a reader not acquainted with Elixir. In particular, functions in Elixir are prefixed by their type declaration which, in general, is an intersection of (multi-arity) arrow types. Thus, we use $\$\bigwedge_{i\in I} \overline{(\,\overline{\,t_i\,}\,)\rightarrow t_i} \kwfn \overline{x} \rightarrow E$ to denote the anonymous function of parameters $\overline{x}$, body $E$ and annotated with the intersection type $\bigwedge_{i\in I} \overline{(\,\overline{\,t_i\,}\,)\rightarrow t_i}$ meaning that when the function is applied to arguments of type $\overline{t_i}$, we expect a result of type $t_i$. Anonymous functions are values, and we notice that besides the form $\$\bigwedge_{i\in I} \overline{(\,\overline{\,t_i\,}\,)\rightarrow t_i} \kwfn \overline{x} \rightarrow E$ above, which is the one introduced in~\cite{CDV24}, we added in red a second form $\$\bigcap \overline{\left(\overline{N:T}\right)\rightarrow T} \kwfn \overline{N}\rightarrow E$ that differs from  the previous one by the annotation that precedes it. These annotations are the new ones we introduce for the module system, which have the particularity that the types in the domain may be named, and that the arrows are on module types; in particular these can use the names specified for the domains (e.g., the code in line~\ref{starttype} declares that the type of the third argument of \elix{start()}, is \elix{Mod.option}, that is the \elix{option} type exported by the first argument of the function \elix{start()}, whatever that will be). We will give more details in Section~\ref{sec:types}.

Let us examine in detail the definition of a module, as given in \eqref{eq:module}:
%
\[\kwdefm X \kwdo \overline{P}\, \overline{S}\, \overline{B} \kwend\]
%
The definition of a module $X$ is a sequence of three blocks: the list $\overline P$ of type parameters of the form $\kwprm \tx$, the list $\overline S$ of behaviours declarations of the form  $\kwbvr \BX$, and the definition of the module itself, which is a sequence of bindings $\overline{B}$. In Elixir, these three blocks may be interleaved, but for the sake of simplicity we will suppose that they are grouped together in the order given above. The module type parameters are used to define the type of the module and are instantiated when the module is used; the list of behaviours specifies the behaviours that this module implements. 

The bindings $\overline{B}$ are used to define the actual implementation of the module, which may include definitions of types, values, and modules.

In a \emph{type binding}, a type $t$ is bound to a (type) name $\tx$, and this binding may be transparent or opaque, as defined by the syntax $\kwtp \tx = t$ and $\kwopq \tx =t$, respectively. An opaque type definition makes the binding $\tx= t$ visible only inside the module, while a transparent one makes this binding visible also outside the module and it is also used to instantiate the parameters of the behaviours the module implements. Thus, for instance if the behaviour \elix{StackB} is defined as the above, then a module \elix{StackInt} implementing the behaviour for integers will be defined as
\begin{minted}{elixir}
defmodule StackInt do            
  !\tp!behaviour StackB                       # declare that the module implements the behaviour StackB 
  !\tp!type elem = integer()                  # instantiate the behaviour parameter
  !\tp!opaque stack = list(integer())         # define the opaque type of the stack

  # callbacks implementations
  !\tp! () -> stack                           # note that elem and stack are type identifiers which
  def new(), do: []                       # which is why I wrote them as stack, elem rather than  
                                          # stack() or elem() ... but this can be discussed
  !\tp! (stack, elem) -> stack
  def push(s, e), do: [e|s] 

  !\tp! (stack) -> {integer(), stack}
  def pop(s), do: {hd(s), tl(s)} 
end
\end{minted}
Although the current Elixir syntax does not allow it, in the system of Figure~\ref{fig:surfacesyntax} we can also define a module to be parametric in some types. For instance, we can define the module stack to be parametric in the type of
its elements, and then pass this parameter as argument to the behaviour, as in
the following example, in which we add a  \elix{top} function and  a
higher-order function \elix{move}
\begin{minted}{elixir}
defmodule StackModule do
  !\tp!param elem
  !\tp!behaviour StackB
  !\tp!type elem = elem              # instantiate the behaviour parameter with the module parameter
  !\tp!opaque stack = list(elem)

  # callbacks implementations
  !\tp! () -> stack
  def new(), do: []

  !\tp! (stack, elem) -> stack
  def push(s, e), do: [e|s] 

  !\tp! (stack) -> {elem, stack}
  def pop(s), do: {hd(s), tl(s)} 

  # extra functions
  !\tp! (stack) -> elem
  def top(s), do: hd(s)

  !\tp! (X: StackB[elem=elem], sx: X.stack, Y: StackB[elem=elem], sy: Y.stack) -> Y.stack
  def move(X, sx, Y, sy), do: Y.push(sy, X.top(sx))
\end{minted}
Now the module \elix{StackModule} is parametric in the type of its elements, and to use it we must instantiate as in \elix{StackModule[elem=integer()].new()} which returns a value of (opaque) type \elix{StackModule[elem=integer()].elem}.

\begin{remark} In order to reduce verbosity one can imagine using the aliasing mechanism of Elixir to define a shorter name for the module type \elix{StackB[elem=integer()]} as in
%\begin{minted}{elixir}

\elix{alias StackModule[elem=integer()], as: StackMInt}

%\end{minted}
\noindent
and then use \elix{StackMInt.new()} to create a new stack of integers.\hfill$\square$
\end{remark}

In a \emph{value binding}, a value $v$ is bound to a name $x$ which may be exported or private, as defined by the syntax $x = v$ and $\kwpr x = v$ respectively. In general, a value $v$ is either a constant of some basic type, or a record of constants, or a function. In the latter case, the function is defined in Elixir by the syntax \elix{def} and \elix{defp} for exported and private functions respectively, and prefixed by their type annotations as in the following example:
\begin{minted}{elixir}
defmodule X do
  !\tp! (!$t_1$! -> !$t_2$!) and (!$t_3$! -> !$t_4$!)
  def f(x,y), do: !$E_1$! 

  !\tp! (X : StackB[elem=integer()], s: X.stack) -> integer()
  defp g(X,s), do: !$E_2$!
end  
\end{minted}
The above examples are considered as syntactic sugar and in the syntax of Figure \ref{fig:surfacesyntax} are rendered by the following definitions 
\begin{minted}{elixir}
defmodule X do
  f = !\tp$(t_1\to t_2) \wedge (t_3 \to t_4)$! fn x, y -> !$E_1$!
  g = !\tp!private !\tp!(X : StackB[elem=int], s: X.stack) !$\to$! int fn X, s -> !$E_2$!
end
\end{minted}

Finally, a \emph{module binding} is a simple definition of the form $\kwdefm X \kwdo \overline{P}\, \overline{S}\, \overline{B} \kwend$  as in \eqref{eq:module}, and binds the module name $X$ with its definitions.


\subsection{The consequences of parametric modules}
While having parametric behaviours is quite straightforward, the addition of parametric modules has several consequences on the syntax and semantics of the module system.


\paragraph{Syntax.} The first important consequence is that this requires an important modification of the current Elixir syntax. If we just allow parametric behaviours and not also parametric modules, then the modification of the syntax of the expressions is really minimal: while currently a module definition just defines transparent types (e.g., \elix{@type state() :: term()}) and opaque ones (\elix{@opaque state() :: term()}), the new type definitions just change this syntax to align to the Elixir new syntax of types, which specify if a type is exported transparently (i.e., both name and definition: $\kwtp \tx = t$) or opaquely (i.e., just its name: $\kwopq \tx = t$), and nothing else for what concerns the expression syntax (in particular modules with this choice are denoted by paths of module identifiers: $X_1.X_2.\cdots{.}X_n$, just like in current Elixir).

If we also allow parametric modules, then we must extend the syntax of module expressions to declare the parameters $\overline P$ in the form $\kwprm \tx$ (easy), but \textbf{above all} we have to change the syntax of paths to allow instantiations of the parameters of modules. This is done by the syntax $X[\overline{\tx=t}]$ denoting the module $X$ instantiated with the types $\overline{t}$ for its parameters $\overline{\tx}$. 
There are two possible syntaxes for paths with instantiations.
\begin{enumerate}
\item The instantiation may occur at any level of a path, as in $X_1[\overline{\tx=t}].X_2[\overline{\tx=t}].X_3[\overline{\tx=t}]$, or
\item The instantiation can only occur at the end of the path, as in $X_1.X_2.X_3[\overline{\tx=t}]$, that is for the innermost module only.
\end{enumerate}
 The former is more general (and it can be easily encoded in 1ML), but can be quite demanding to the programmer, especially if the system requires all parametric modules in a path to be explicitly instantiated.


 The latter is simpler, it reflects the current implementation of Elixir, where the nesting of modules is just a syntactic facility since all modules are flat and the nesting is handled by the compiler by naming each nested module with the full and unique path to it. \beppe{Explain that this is important for refactoring} This second choice however imposes to carefully define the scoping rules of types in a module. In particular:
 \begin{itemize}  
  \item the parameters of a module $X$ are not visible in the modules nested in $X$;
  \item a type $\tx$ defined in a module $X$ is visible in all modules nested in $X$ only if all the types used in the definition of $\tx$ are visible in the nested modules.
  \item a value $x$ defined in a module $X$ is visible in all modules nested in $X$ only if all the types used in the type of $x$ are visible in the nested modules.
 \end{itemize}
 This implies that to use a type or a value non-visible in a nested module, we must use a full and explicitly (and terminally) instantiated path to denote it.
 Actually this is completely in line with the current Elixir implementation, where nested modules do not have access to the types and values defined in their enclosing module(s), unless these are explicitly denoted by their full path.

The reader may have noticed that we used a different color in three terms of the syntax: the parameters $\kwdefm X \kwdo \textcolor{Cerulean}{\overline{P}}\, \overline{S}\, \overline{B} \kwend$ in module definitions; the type of modules $\left\{\textcolor{Cerulean}{\overline{P}};\overline{S};\overline{D}\right\}$; the instantiation $X\textcolor{Cerulean}{[\,\overline{\tx=t}\,]}$ in module denotations. The colored syntax denotes all the modifications to the syntax of Elixir \textbf{expressions} that are needed to implement parametric modules. In the current  Elixir expression syntax, a module is denoted only by its name since there are no parametric modules, therefore no parameter instantiation: paths are only of the form \elix{Mod1.Mod2.Mod3} rather than, say, \elix{Mod1[x=integer()].Mod2.Mod2[z=proc()]} (in the variant that corresponds to $M::= M.M \mid X[\overline{\tx=t}]$), or its terminal variant \elix{Mod1.Mod2.Mod2[z=proc()]} (corresponding to $M::= X.M\mid X[\overline{\tx=t}]$)

If do not want to extend the current Elixir syntax for expressions to allow parametrized modules such as \elix{StackModule}, it suffices to remove the syntax colored in blue  from Figure~\ref{fig:surfacesyntax}, that is, instantiations in module, and the type parameters in module types and definitions (the two definitions of paths in that case collapse).\footnote{Of course, we will still replace Typespec specifications with our new syntax for types.} Then all the modifications to type the Elixir module system will be confined to types and type-related definitions, and the expressions will remain unchanged. In particular, type parameters will be confined to behaviours. 


\paragraph{Inference.} A second important consequence of parametric modules is that we have to decide how much inference we want to (and can) do for the type arguments of a parametrized module. This is more a matter of programming style than of formalization, though the choice may have some consequences on the formalization.
In the example of \elix{StackModule} above, for instance, we have to decide whether we want the programmer always to specify the type parameters of a module when this is used, as in \elix{StackModule[elem=integer()].new()}, or whether we want the system to be able to infer the type parameters from the context, as in \elix{StackModule.push(StackModule.new(),5)}. The latter is more convenient for the programmer, but requires a more complex type system. In particular, it requires a form of local type inference, since the type of \elix{StackModule.new()} must be inferred to be \elix{StackModule[elem=integer()].stack} from the context in which it is used (the first argument of \elix{push}). This also poses some problems of deciding how precisely the type parameters must be inferred. For instance, in \elix{StackModule.push(StackModule.new(),:a)}, should the system infer \elix{elem=atom()} or \elix{elem=:a}? The former is more general (and probably what a programmer would expect), but the latter is more precise.

The easy way is to always require the programmer to specify the type parameters of a module when this is used and extend the aliasing mechanism of Elixir to allow the programmer to define local aliases for instantiated modules, as in
\begin{minted}{elixir}
defmodule MyApp do
  alias StackModule[elem=integer()], as: IntStack
  s = IntStack.new()
  s1 = IntStack.push(s,5)
end
\end{minted}
This is simpler to formalize, but may be a bit too demanding for the programmer.



\subsection{Types}\label{sec:types}
\beppe{This section must be rewritten on the lines discussed in Section~\ref{sec:stratification}.}

The types for expressions are strictly stratified. There are the simple types, ranged over by $t$ which are essentially  those of \cite{CDV24} with a single syntactic extension, $M.\tx$ denoting the simple type exported by the module $M$ as $\tx$. 
%
%
\beppe{If we want this strict stratification we have to 
\begin{itemize} \item Move behaviours into $T$. The consequence of this is that we cannot have a type binding of the form  $\kwtp \tx ={\BX}[\,\overline{\tx= t}\,]$, that is, a module cannot export a module type. I do not see any other consequence.
  \item this also means that we cannot have maps (and products if included) containing modules. If we want to have it we can modify the definition of field types $f$ so that the map labels to $T$, rather than $t$. The problem however is how to define union and intersections of map types with $T$ fields, since unions and intersections are not defined on $T$. As long as we do not have a semantic interpretation of $T$ we should mix syntactic and semantic subtyping.
  \item A possible intermediate solution could be to have map types to specify intersections of instantiated behaviours, $\bigcap\overline{\BX[\,\overline{\tx= t}\,]}$ as these can be considered as new basic types (modulo the ordering of the parameter instatiations) for which it is easy to define semantic subtyping. \end{itemize}}
  %
  
  On the top of the simple types there are the module system types, ranged over by $T$, which are either (fully instantiated) behaviours $\BX[\,\overline{\tx= t}\,]$, or (anonymous) module types of the form $\left\{{\overline{P}};\overline{S};\overline{D}\right\}$,\footnote{
  Programmer will not have the possibility to write this type. We are rather oriented to allow the programmer only to specify in types either some behaviour names (e.g., \felix{StackB[elem=integer()]}), or use the \texttt{Like$\;M$} syntax (e.g., \felix{Like StackInt} to denote the anonymous module type of the \felix{StackInt} module.} or  the types of functions working on modules, of the form $(N_1{:} T_1,\cdots, N_n{:}T_n) \to T_{n+1}$, where $N_i$ is a parameter name, and $T_i$ is a module system type in which the names $N_j$ for $j<i$ may occur (e.g. \elix{(X : StackB[elem=integer()], s : X.stack) -> X.elem}).

  These module system types have the following intended meaning:
  \begin{itemize}
    \item A module $X$ has a behaviour type $\BX[\,\overline{\tx= t}\,]$ if it explicitly implements the behaviour $\BX$ instantiated with the types $\overline{t}$ for its parameters $\overline{\tx}$. This means that that the definition of the module $X$ contains the declaration $\kwbvr \BX$, a transparent type definition $\kwtp \tx_i=t_i$ for each  $\tx_i, t_i$, in $\overline{\tx}, \overline t$, and provides a definition for all the values, modules, and callbacks declared in $\BX$, with the types declared in $\BX$. 
    \item The type of a module is defined by the syntax $\left\{\overline{P};\overline{S};\overline{D}\right\}$, where $\overline{P}$ are the type parameters of the module, $\overline{S}$ is the list of behaviours implemented by the module, and $\overline{D}$ is a type environment, that is, the list of the typings of the definitions exported by the module. These typings are of the form $\kwmdl X : T$ for modules, $\kwclbk x : \bigcap \overline{T}$ for value definitions (constant, record values, and functions/callbacks), $\kwopq \tx$ for opaque types, and $\kwtp \tx = t$ for transparent types (of course, no type for private definitions). This list must contain at least the typings for all the type parameters and the callbacks of the behaviours $\overline{S}$ implemented by the module. The usual restrictions of Elixir apply: a module cannot implement two  behaviours with a common callback. 
    \item The type $(N_1{:} T_1,\cdots, N_n{:}T_n) \to T_{n+1}$ is used to type functions working on modules. The parameters $N_i$ are names that can be used in the types $T_j$ for $j>i$ to denote types exported by the module passed as $i$-th argument (e.g., the \elix{move} function of the \elix{StackModule} example above, which has type \elix{(X : StackB[elem=elem], sx : X.stack, Y : StackB[elem=elem], sy : Y.stack) -> Y.stack}.)
\end{itemize}

  One of the consequences of this stratification---actually, its main motivation---is that set-theoretic type connectives such as $\vee$, $\wedge$, and $\neg$ are not allowed in module system types, but only in simple types. The reason is that we do not have a semantic interpretation of the $T$ types and therefore we cannot define the set-theoretic connectives on them.


  In practice, however we need intersection types on module system types in at least two cases: when we want to define a module $M$ that implements several behaviours (since the type of the module is its anonymous type \texttt{like($M$)} intersected with its properly instantiated behaviours), and when we want to define a multiclause function in which some clauses are defined for module system types (we expect the function to have an intersection of $(\overline{N:T})\to T$ arrows). Both cases are represented in the syntax of Figure~\ref{fig:surfacesyntax} by handling them syntactically. A module system type $\left\{\overline{S};\overline{D}\right\}$ represent the intersection of the anonymous type $\left\{\overline{D}\right\}$ with the behaviours $\overline{S}$, instantiated as indicated in $\overline{D}$. This will be clearer in the formalization where module types have the form $\{\overline{D}\}_{\overline{\BX}}$ to be interpreted as the syntactic intersection $\{\overline D\}\cap{\BX_1}\cap...\cap{\BX_n}$. For the second case, we use the syntax $\bigcap \overline{T}$ to declare callback types and annotate exported functions. We use $\bigcap$, rather than $\bigwedge$ to stress that this is an intersection different from the one on simple types, the former being defined syntactically (via some explicit subtyping rules), the latter semantically (via a set theoretic interpretation of types).

  


\section{Formalization of the module system}

\subsection{Syntax changes}

For our formalization we will use a slightly different syntax, which is more convenient for the type system we are going to define. This syntax  is given in Figure \ref{fig:modulelangsyntax}. 
\begin{figure}
  \begin{tabular}{r c ll}
    $\mathcal B$ &::= &  $\!\!\BX: \Lambda(\overline{\tx:\star}).\{\overline{D}\}$ &\color{Gray} behaviour $\BX$ with parameters $\overline \tx$\\
    $B$ &::= &  $\!\!X = \textcolor{Cerulean}{\Lambda(\overline{\tx:\star}).}\{\overline{B}\}_{\overline{\mathcal{X}}}$ &\color{Gray} module $X$ with parameters $\overline \tx$ implementing $\overline{\BX}$\\
    & | & $x = v$                                   &\color{Gray} exported definition \\
    & | & $x = \textsf{private }v$                  &\color{Gray} private definition\\
    & | & $\tx = \textsf{type }t$                     &\color{Gray} transparent type or behaviour argument\\
    & | & $\tx = \textsf{opaque }t$                   &\color{Gray} opaque type\\[3mm]
    $M$ & ::= & $X\textcolor{Cerulean}{[\,\overline{\tx=t}\,]}$                 &\color{Gray} local module\\
 %   & | & $M.M$                                     &\color{Gray} imported module\\
    & | & $X.M$                                     &\color{Gray} imported module (flat hierarchy): later we can study $M.M$\\[3mm]
   $N$ & ::= & $x$ \\
    & | & $X$ \\[3mm]
   $E$ &::= & $v$ \\
    & | & $x$ \\
    & | & $\kwlet N = E\kwin E$ \\
    & | & $E(\overline{N})$ \\
    & | & $\texttt{\%}\!\left\{\overline{\ell=E}\right\}$ \\
    & | & $E.\ell$ \\
    & | & $(E\in t)?E:E$ \\
    & | & {\color{OrangeRed}\text{$M.x$}} \\
    & | & {\color{OrangeRed}\text{$M$}} \\
    $v$ & ::= & $c$ \\
    & | & $\texttt{\%}\!\left\{\overline{\ell=v}\right\}$ \\
    & | & $\$\bigwedge \overline{(\,\overline{t}\,)\rightarrow t} \kwfn \overline{x} \rightarrow E$ \\
    & | & {\color{OrangeRed} \text{$\$\bigcap \overline{\left(\overline{N:T}\right)\rightarrow T} \kwfn \overline{N}\rightarrow E$}} &\color{OliveGreen} syntactic intersection\\[3mm]
    $T$ & ::= & $t$ \\
    & | & $\left(\overline{N:T}\right)\rightarrow T$ \\
    & | & $\left\{\overline{D}\right\}_{\overline{\BX}}$ &{\color{OliveGreen} syntactic intersection: $\{\overline{D}\}\cap{\BX_1}\cap...\cap{\BX_n}$}: ($\BX$'s instantiations given in $\overline{D}$)\\
    & | & $\textcolor{Cerulean}{(\overline{\tx:\star})\to T}$        & \text{it allows to pass around non instantiated parametric modules ... do we want it?} \\
     & | & \color{Gray} $\textcolor{Gray}{(\overline{\tx:\star})\to \left\{\overline{D}\right\}_{\overline{\BX}}}$ & isn't it enough to have only this one, instead of the previous one?\\[3mm] 
  %  & | & $\star$ &\text{\small I would remove this production: we do not want to pass around modules unless}\\
  %                &&&\text{\small they are fully instantiated} $f(X:(\tx:\star)\to ...)\to ...X[\tx=\textsf{int}] ...$\\
    $t$ & ::= & $\texttt{atom}$ \\
    & | & $\texttt{mod}$ & top module type \\
    & | & $\texttt{fun}$ & top function type \\
    & | & $(\overline{\,t\,})\rightarrow t$\\
    & | & $\texttt{\%}\!\left\{\overline{f}\right\}$ \\
    & | & $t\vee t$ \\
%    & | & $t\wedge t$ & \aghilas{we can remove this one}\\
    & | & $\neg t$\\
    & | & $\alpha$ \\
    & | & $\mathbb{O}$ \\
    & | & \textcolor{OrangeRed}{\text{$M.\tx$}}                          &\color{Gray} the type $\tx$ imported from module $M$\\
    & | & \textcolor{OrangeRed}{\text{$\mathcal{X}[\overline{\tx=t}]$}}  &\color{Gray} a behaviour (essentially a like a new constant of the basic type module())\\
  %  &&&\color{bordeaux} Important: this allows maps and tuples to contain modules!\\
    & | & \textcolor{OrangeRed}{\text{$\BH M$}} &\color{Gray} the singleton type of $M$ (modulo path equivalence)\\[3mm]
    $D$ & ::= & $X : T$                               &\color{Gray} exports a module $X$ of type $T$\\
    & | & $x : \bigcap \overline{T}$                  &\color{Gray} exports a value $x$ of type $\bigcap\overline T$ \\
    & | & $\tx : \star$                                 &\color{Gray} exports an opaque type $x$\\  
    & | & $\tx : [=t]$                                  &\color{Gray} exports a transparent type $x = t$  \\[3mm]
    $\Gamma$ & ::= & $\overline{D}$ &\color{Gray} type environment\\
    $\Sigma$ & ::= & $\overline{\mathcal B}$ &\color{Gray} behaviour environment\\[4mm]
  \end{tabular}

 where $\BX$ ranges over behaviour names, $X$ over module names, $x$ over variable names, $\tx$ over type names, and $\ell$ over map keys. 
  \caption{Module language syntax}\label{fig:modulelangsyntax}
\end{figure}



The main differences with respect to the Elixir syntax are the following:

\begin{enumerate}
  \item The module type $\kwdefmt \BX\kwdo \overline{\kwprm \tx}\, \overline{D} \kwend$ is written as $\BX: \Lambda(\overline{\tx:\star}).\{\overline{D}\}$.
  \item The module definition $\kwdefm X \kwdo \overline{\kwprm \tx}\; \overline{\kwbvr \mathcal{X}}\; \overline{B} \kwend$ is written as $X = \Lambda(\overline{\tx:\star}).\{\overline{B}\}_{\overline{\mathcal{X}}}$
  \item We changed the syntax of module binding so that all the bindings are of the form (\emph{name $=$ definition}): this is the main motivation for the change of syntax in point 2 above.
  \item Likewise, the types of module bindings has been modified so that all the binding are of the form (\emph{name $:$ definition-type}). This is the main motivation for the change of syntax in point 1 above.
  \item Expression can be applied only to a list of names, and not to arbitrary expressions. It is however easy to encode the expression $E_0(E_1,...,E_n)$ as $\kwlet N_1 = E'_1 \kwin ... \kwlet N_n=E'_n\kwin E'_0(N_1,\dots,N_n)$, where $E'_i$ is the encoding of expression $E_i$, and $N_i$ are fresh names.  
\end{enumerate}
There is a clear mapping from the terms of Figure~\ref{fig:surfacesyntax} to those of Figure~\ref{fig:modulelangsyntax}, therefore we will not discuss this further.


\bigskip 

\beppe{Open question: what about recursion in module types? Do we want to allow it? If yes, how? Few gut feelings:
\begin{itemize}
  \item recursion must not traverse instantiations: that is we cannot have $\mu \alpha .\BX[\tx=\alpha[\tx=t]]$ (whatever this means);
  \item we definitively want to allow mutually recursive modules, and therefore we want to allow mutually recursive module types; but this must be done in a controlled way. For instance, we do not want $M.t = M'.u$ and $M'.u = M.t$ as this creates an infinite loop when trying to expand the types; the question is does normal contractivity suffice here (infinite unfolding must traverse infinitely many arrows or map constructors)?
\end{itemize}
Shall we postpone the problem to future work? \textbf{In any case the current formalization does not handle mutually recursive modules since the well-formation rules require modules to be defined before being used. Which means that this is an orthogonal problem, the system we define here assumes modules comes as defined.}}
\subsection{Types}

Types are either the simple types $t$, or the module system types $T$. We have already discussed the syntax and intended meaning of these types before, therefore we will not repeat it here. This stratification is important to define type containment. We will use two different techniques to define the subtyping relation. For simple types we will define semantic subtyping, by interpreting them into sets of elements of a domain and defining subtyping as the containment of the interpretations. For module system types $T$ we will define a syntactic subtyping relation via a deduction system. The stratification of types allows us to define subtyping on modules types $T$ by structural induction on their syntax, using the semantic subtyping on simple types $t$ when needed. Next we are going to discuss the consequences of this stratification and then we will give the formal definitions of types and their interpretation.



\subsubsection{Stratification}\label{sec:stratification}

The important point of our type system is that types are strictly stratified: module system types $T$ can contain simple types $t$, but not vice versa. This stratification has several important consequences. On the positive side, it allows us to define a semantic interpretation of simple types $t$ as sets of values, and therefore a semantic subtyping relation on simple types $t$, and a syntactic subtyping relation on module system types $T$. For this reason we hereafter we will also call simple types as \emph{semantic types} and $T$ types as syntactic types. On the negative side, the only proper subtypes of \texttt{module()} that can occur in simple types $t$ are (Boolean combinations of) fully instantiated behaviours $\BX[\overline{\tx=t}]$. This means that in a tuple or a map or a list of Elixir, only modules that implement some behaviour can occur in them. To palliate this limitation, we added to simple types the singleton types of fully instantiated modules. 

\begin{remark}
In practice, one can envisage to provide the programmer some syntax to denote structural module types. A possibility is to add to the Elixir language of types the \texttt{like($M$)} syntax to denote the anonymous structural type of a (fully instantiated) module $M$ as well as a more programming friendly synatax \texttt{behaviour\_of($M$)} to denote the singleton type $\langle M\rangle$. Of course while \texttt{behaviour\_of($M$)} can be used in simple types $t$, the type \texttt{like($M$)} can be used only in module system types $T$. Such additions do not change the underlying type theory we present next.
\end{remark}

Next we are going to discuss the semantic interpretation of simple types $t$. As we will see we need a further stratification of simple types $t$ into the current Elixir types and the new types we added to handle modules.



\subsubsection{Semantic subtyping for simple types}
Simple types, ranged over by $t$ are essentially the types of Elixir defined in \cite{CDV24,CD25}, with the addition of the three new forms: $M.\tx$, $\BH M$, and $\BX[\overline{\tx=t}]$. The first denotes the type $\tx$ exported by the module $M$, the second the singleton type of the fully instantiated module $M$, while the third denotes the behaviour $\BX$ instantiated with the types $\overline{t}$ for its parameters $\overline{\tx}$.

The Elixir types and the three additional forms are essentially different in their nature. The Elixir types have a clear semantics that it is independent of the program they are used in. Furthermore, they are conductively defined in order to account for recursive types. The three new forms instead have a semantics that is strictly related to the program they are used in: in particular, the semantics of $M.\tx$ and $\BH M$ depends on the definition of the module $M$, while the semantics of $\BX[\overline{\tx=t}]$ depends on the definition of the behaviour $\BX$. Furthermore, we do not want to allow recursion to traverse these new forms, and this for two reasons: first we do not want a non-recursive module or behaviour to become recursive by using instantiation: think of a recursive  type like $\mu \alpha .\BH{X[t=\alpha]}$ where $X$ is a non-recursive module, or $\mu \alpha .\BX[\tx=\alpha]$ where $\BX$ is a non-recursive behaviour; second, such a recursion would complicate the semantic definitions, by introducing a new circularity: types such as $\BH{X[\overline{\tx=t}]}$ and $\BX[\overline{\tx=t}]$, must be interpreted as singletons modulo the interpretation of the types used in their instantiations; so to interpret these types we must determine the equivalence of the types of their instantiations, for which we need the interpretation of all the types, them included.

For these reasons we will further stratify simple types $t$ into the current Elixir types, which we will call \emph{core types}, which are \emph{coinductively} defined by the following grammar:
$$\tau ::= k\mid\texttt{atom} \mid \texttt{mod} \mid \texttt{fun} \mid (\overline{\tau})\to\tau \mid \texttt{\%}\!\left\{\overline{k:\tau}\right\} \mid \tau\vee\tau \mid \neg\tau\mid\alpha\mid\mathbb{O}$$
The simple types $t$ are then defined on the top of the core types $\tau$ \emph{inductively} by the following grammar:
$$t ::= \tau \mid  (\overline{t})\to t \mid \texttt{\%}\!\left\{\overline{\ell:t}\right\} \mid t\vee t \mid \neg t\mid M.\tx \mid \BH M \mid \BX[\overline{\tx=t}]$$
This stratification allows us to define the semantic interpretation of core types as sets of values, and the semantic of the simple types by giving an encoding of the new forms $M.\tx$, $\BH M$, and $\BX[\overline{\tx=t}]$ into core types. This encoding will be parametric in the definitions of the modules and behaviours of the program, since the semantics of these new forms depends on the definitions of the modules and behaviours they refer to. In this way instead of giveing an interpretation parametric in the program, we just give an encoding of the new forms parametric into it.

Formally, we have the following definitions.

\begin{definition}[Core Types]\label{def:coretypes}
  Let $k$ range over atoms, $\BX$ over behaviour names, $\tx$ over type names, and $M$ over module paths.
  The set $ \Coretypes $ of \emph{core types} is the set of terms $ \tau $
  that are \underline{coinductively} produced by the following grammar
  \[
    \tau ::= k\mid \texttt{atom} \mid \texttt{mod} \mid \texttt{fun} \mid (\overline{\tau}) \to \tau \mid  \texttt{\%}\!\left\{\overline{k:\tau}\right\} \mid
    \tau \lor \tau \mid \lnot \tau \mid \Empty\mid \alpha
  \]
  and that satisfy two additional constraints: $(1)$ \emph{regularity}:
          the term must have a finite number of different sub-terms; $(2)$ \emph{contractivity}:
          every infinite branch must contain an infinite number
          of occurrences of the product or arrow type constructors.
\end{definition}

\begin{definition}[Pretypes]\label{def:types}
  Let $\tau$ range over core types, $X$ over module names, $\BX$ over behaviour names, $\tx$ over type names, and $M$ over module paths.
  The set $ \Types $ of \emph{pretypes} is the set of terms $ t $
  that are \underline{inductively} produced by the following grammar
  \[
    t ::=  \tau \mid  (\overline{t}) \to t \mid \texttt{\%}\!\left\{\overline{k:t}\right\} \mid
    t \lor t \mid \lnot t \mid M.\tx \mid \BX[\overline{\tx=t}] \mid \BH M
  \]
\end{definition}
Core types are a relevant subset the polymorphic types of Elixir defined in \cite{CDV24,CD25}. they include a singleton type $k$ for each atom $k$, the basic types \texttt{atom} of all atoms, \texttt{mod} of all modules, and \texttt{fun} of all functions, the arrow type $(\overline{\tau}) \to \tau$ for multi-arity functions, the open map type $\texttt{\%}\!\left\{\overline{k:\tau}\right\}$ mapping atom keys to core types, the set-theoretic connectives union $t_1 \lor t_2$, negation $\lnot t$, and the empty type $\Empty$, as well as type variables, ranged over by $\alpha$.


Coinduction accounts for recursive types, and it is coupled with a
contractivity condition which excludes infinite terms
that do not have a meaningful interpretation as types or sets of values:
for instance, the trees satisfying the equation
$ \tau = \tau \lor \tau $
(which gives no information on which values are in it)
or $ \tau = \lnot \tau $ (which cannot represent any set of values) do not
satisfy the contractivity condition.
Contractivity also gives an induction principle on the set of core types that allows us to apply the induction hypothesis
below type connectives (union and negation),
but not below type constructors (product and arrow).

The subtyping relation for core types is defined semantically by interpreting them as sets of values,  and defining subtyping as the containment of the interpretations. The interpretation of functional core types is standard and can be found in \cite[Sections 3.1 and 4.2]{DubocThesis26} (see~\cite[Section 3.2]{Cas24} for a much simpler overview), and so is the interpretation of map types, which are interpreted as quasi-constant functions from labels to sets of values as in \cite{Cas23}. The only difference is that the set of labels contains not only the atoms but also all the type names $\tx$ and three special labels $\texttt{\@p}, \texttt{\@o}, \texttt{\@n}$, since we use them in our encoding of types into core types, as we will see later. 


Pretypes are called as such because we will select among them the one that are well-formed with respect to a given definition of modules and behaviors.
The include core types and their type constructors and connectives, plus the three new types for modules: the type $M.\tx$ for the type $\tx$ exported by the module $M$, the behaviour type $\BX[\overline{\tx=t}]$ for the behaviour $\BX$ instantiated with the types $\overline{t}$ for its parameters $\overline{\tx}$, and the singleton module type $\BH M$.


We use the abbreviations
$
  t_1 \land t_2 \eqdef \lnot (\lnot t_1 \lor \lnot t_2)
$, $
  t_1 \setminus t_2 \eqdef t_1 \land (\lnot t_2)
$, and $
  \Any \eqdef \lnot \Empty
$ (in particular, $\Any$ is the supertype of all types, denoted in Elixir by \elix{term()}).
We refer to $ b $, $ \times $, and $ \to $ as \emph{type
constructors}, and to $ \lor $, $ \lnot $, $ \land $, and $ \setminus
$ as \emph{type connectives.} As customary, connectives have priority
over constructors and negation has the highest priority---e.g., $\neg
s{\vee}t\to u{\wedge}v$ denotes $((\neg s){\vee}t)\to (u{\wedge}v)$.


\beppe{<UP TO HERE>}

TODO: 
\begin{itemize}
\item encoding of well-formed types into core types, parametric in $\Sigma$ and $\Gamma$
\end{itemize}
\aghilas{ there is still a question for the encoding to core types: if $M.\tx$
  is transparent equal to $t$ how to encode $t$ to a core type as it is not a
  subtype of $M.\tx$ and that it is not defined in the same $\Gamma$. Modifying
  the syntax of declaration types to have: $\tx:[=\tau]$ would fix the issue. If
  we note $\Sigma;\Gamma\vdash \wr t\wr =\tau$ the encoding. Then we express this
  idea as the following rules.
  \begin{mathpar}
    \inferrule[Bind-Type]
       {\Sigma;\Gamma\vdash t:\star\\
         \Sigma;\Gamma\vdash \wr t\wr=\tau\\
        \Sigma;\Gamma, x:[=\tau]\vdash\overline{B}:\overline{D}}
       {\Sigma;\Gamma\vdash\left(x=\textsf{type }t\right)\overline{B}: \left(x:[=\tau]\right)\overline{D}}
       \\
\inferrule[Bind-Opaque]
       {\Sigma;\Gamma\vdash t:\star\\
         \Sigma;\Gamma\vdash \wr t\wr=\tau\\
        \Sigma;\Gamma, x:[=\tau]\vdash\overline{B}:\overline{D}}
       {\Sigma;\Gamma\vdash\left(x =\textsf{opaque }t\right)\overline{B}:  \left(x:\star\right)\overline{D}}
  \end{mathpar}
}

Let us start with the interpretation of $\BX[\overline{\tx=t}]$. Notice that we can deal with the type \texttt{module}, the top module type, in the same way as we did for \texttt{atom} in \cite{CD25}, as it can be considered as the infinite union of all the singleton types that form it. In the case of \texttt{atom} the singleton types are the single atoms. In the case of \texttt{module} the singleton types are all the fully instantiated behaviours, modulo the equivalence of their instantiation. Then every type contained in \texttt{module} is either a finite or a cofinite union of fully instantiated behaviours.
Therefore, we can define the interpretation of $\BX[\overline{\tx=t}]$ as the set containing all the equivalent instantiations of the behaviour $\BX$, where $\BX[\overline{\tx=t}]\simeq\BX[\overline{\tx=t'}]$ iff for every $\tx_i=t_i$, we have $t_i\simeq t'_i$ (the order of the parameters does not matter, just their names and instantiations). Adding the \texttt{behaviour\_of($M$)} singleton types as suggested in Section \ref{sec:stratification} does not change the theory as these behaviours are singletons, modulo the equivalence on $M$ (see Figure~\ref{fig:pathequivalence}). Bottom line, behaviours are a new basic type handled exactly as \elix{atom()}.


For what concerns the interpretation of $M.\tx$, we can always use the type of the module names that form $M$ to deduce the simple type $M.\tx$ denotes. This is either a transparent type $t$, in which case we can define the interpretation of $M.\tx$ as the interpretation of the type $t$, or it is an opaque type, in which case we consider $M.\tx$ as a type variable (modulo the equivalence of paths defined in Figure~\ref{fig:pathequivalence}). It is important to notice that $M.\tx$ must be well-formed, that is the last module in the path $M$ (or the also all the intermediates modules of the path if we use the more general syntax for paths) must be completely instantiated, so that we can always deduce the type bound to $\tx$.

Formally, we have the following definition of pretypes, where we replaced product types for record types. Types will be defined as the well-formed pretypes.
\begin{definition}[Pretypes]\label{def:types}
  Let $X$ range over module names, $\BX$ over behaviour names, $\tx$ over type names, and $M$ over module paths.
  The set $ \Types $ of \emph{pretypes} is the set of terms $ t $
  that are coinductively produced by the following grammar
  \[
    t ::= b \mid t \times t \mid (\overline{t}) \to t \mid  M.\tx \mid \BX[\overline{\tx=t}] \mid \BH M\mid
    t \lor t \mid \lnot t \mid \Empty\mid \alpha
  \]
  and that satisfy two additional constraints: $(1)$ \emph{regularity}:
          the term must have a finite number of different sub-terms; $(2)$ \emph{contractivity}:
          every infinite branch must contain an infinite number
          of occurrences of the product or arrow type constructors.
\end{definition}
(Pre)types include  basic types $b$ (including at least the basic type \textsf{int} for integers, \textsf{mod} for the top module type, and \textsf{fun} for the top function type). They include the product type $t_1 \times t_2$ for products, the arrow type $(\overline{t_1}) \to t_2$ for multi-arity functions, the type $M.\tx$ for the type $\tx$ exported by the module $M$, the behaviour type $\BX[\overline{\tx=t}]$ for the behaviour $\BX$ instantiated with the types $\overline{t}$ for its parameters $\overline{\tx}$, and the singleton module type $\BH M$. They also include the set-theoretic connectives union $t_1 \lor t_2$, negation $\lnot t$, and the empty type $\Empty$, as well as type variables, ranged over by $\alpha$.



The types are essentially the same as in \cite{CDV24}, with the addition of the three new forms for modules: $\BX[\overline{\tx=t}]$, $\BH M$, and $M.\tx$. These additions require the definition of type well-formation: $\BX[\overline{\tx=t}]$ requires the full instantiation of $\BX$ (i.e., $\BX$ is a behaviour with parameters $\overline\tx$ instantiated by well-formed types $\overline{t}$); $\BH M$ requires the path $M$ to be well-formed, namely that it effectively points to a fully instantiated module \beppe{In future we may study whether fully instantiation is necessary/desirable, at least in singleton modules but even in paths}; $M.\tx$ requires the path $M$ to be well-formed and the type $\tx$ to be defined in the module $M$. All the other types are well-formed if all their sub-terms are well-formed. Clearly well-formedness depends on definition of the modules and of the behaviours. Therefore, type good formation is given by judgment of the form $\Sigma,\Gamma\vdash t:\star$, where $\Sigma$ is a behaviour environment mapping behaviour names $\BX$ to their definition (of the form $\Lambda(\overline{\tx:\star}).\{\overline D\}$) and $\Gamma$ is a typing environment mapping expressions names (i.e., module names and expression variables) into module types (in particular it maps module names into types either of the form $\left\{\overline{D}\right\}_{\overline{\BX}}$ or of the form $(\overline{\tx:\star})\to \left\{\overline{D}\right\}_{\overline{\BX}}$. These environments must also be well-formed, meaning that all the types occurring in them are well-formed and fully instantiated where needed.


\paragraph{Module scoping rules.} A module has access to all its definitions, including the private ones, and to all the definitions of the modules in its scope. Order is important thus at a given point of the module only the preceding definitions are available. A module can access to the definitions  of outer modules only by using an absolute path starting from a top-level module name; in that case however it has access to all (public) definitions of the outer module, even those defined after the inner module.

\noindent\rule{\textwidth}{0.4pt}

TODO:
\begin{itemize}
  \item Define the interpretation of types $\llbracket t\rrbracket$ as sets of values. The one for behaviours needs type equivalence, the one for $M.\tx$ instead is not clear (indeed we avoided this problem by using coinductive definition but having paths in type implicitly introduces recursion variables). Maybe we can define it as follows:
    \begin{itemize}
      \item if $M.\tx$ is bound to a transparent type $t'$, then $\llbracket M.\tx\rrbracket = \llbracket t'\rrbracket$; (contractivity should guarantee that the definition is well founded)
      \item if $M.\tx$ is bound to an opaque type, then $\llbracket M.\tx\rrbracket = $\texttt{var\_of($M$)}, where \texttt{var\_of($M$)} is a function that maps equivalent paths into the same fresh type variable (is this well defined? equivalence needs subtyping which needs interpretation of types... ).
    \end{itemize}
\end{itemize}

\aghilas{\paragraph{Applicative vs. Generative} Type application should be
  applicative. We might want general application (i.e. when a function returns a
  module) to be generative by default. We could add an option to let users
  declare that a function should be applicative (how to decide equality ?). }

\beppe{From here I suppose that we have definied the subtyping relation $t\leq t'$ on simple types, therefore their equivalence $t\simeq t'$ as $t\leq t'$ and $t'\leq t$, and and the good formation judgment $???\vdash t:\star$.}

\subsubsection{Syntactic subtyping for module system types}
The subtyping relation on module system types $T$ is defined syntactically,
since we do not have a semantic interpretation of these types. This is possible
since module system types are stratified and therefore we can define subtyping
on the module types $T$ by structural induction on their syntax, using the
semantic subtyping on simple types $t$ when needed.

The main rules are the following:

\paragraph{Type good formation.} First of all, we have to define when a module system type $T$ is well formed. This is done by the rules in Figure~\ref{wf-modtype}, which essentially check the following conditions: $(1)$ in a function type $(\overline{N:T})\to T'$, the names $N_i$ are  used only in the types $T_j$ for $j>i$; $(2)$ in a module type $\{\overline{D}\}_{\overline{\BX}}$, the definitions $\overline{D}$ must contain at least the definitions of all the parameters and callbacks of the behaviours $\overline{\BX}$, instantiated as indicated in $\overline{D}$. 

\beppe{TO BE CONTINUED}

\aghilas{ We have two different environments: $(1)$ the behaviour environment
  (noted $\Sigma$) maps behaviour names ($\BX,\BY,\ldots$) to behaviours:
  $\mathcal{B}$; $(2)$ the value environment (noted $\Gamma$) which contains
  four types of mappings: $D$.
  A value environment is, in fact, a list of declarations, the good formation
  rules for both are thus the same.

  We define the following good formation judgments:
  \begin{itemize}
    \item Good formation of behaviour environments: $\Sigma\vdash\Sigma'$ (Figure~\ref{wf-behenv});
    \item Good formation of value envirnoments: $\Sigma;\Gamma\vdash\Gamma'$ (Figure~\ref{wf-valenv});
    \item Good formation of types: $\Sigma;\Gamma\vdash t:\star$, we will
      replace $t$ by the inductive layer of our stratification, the rules will
      be the same as~\ref{wf-type};
    \item Good formation of module system types: $\Sigma;\Gamma\vdash T$ (Figure~\ref{wf-modtype});
    \item Good formation and typing of paths: $\Sigma;\Gamma\vdash M:\{\overline{D}_{\mathcal{X}}\}$.
  \end{itemize}

\begin{figure}[ht]
  \begin{mathpar}
    \inferrule[WFBehEnv-Empty]{\\}{\vdash\epsilon}\hfill
    \inferrule[WFBehEnv-Beh]{\Sigma;\overline{\tx:\star}\vdash\{\overline{D}\}_\BX}{\Sigma\vdash\Sigma,\BX:\Lambda(\overline{\tx:\star}).\{\overline{D}\}}
  \end{mathpar}
  \caption{Good formation of behaviour environments}\label{wf-behenv}
\end{figure}
\begin{figure}[ht]
  \begin{mathpar}
    \inferrule[WFValEnv-Empty]{\\}{\Sigma;\epsilon\vdash\epsilon}\hfill
    \inferrule[WFValEnv-Opaque]{\\}{\Sigma;\Gamma\vdash\Gamma,\tx:\star}\hfill
    \inferrule[WFValEnv-Concrete]{\Sigma;\Gamma\vdash t}{\Sigma;\Gamma\vdash\Gamma,\tx:[= t]}\\
    \inferrule[WFValEnv-Value]{\Sigma;\Gamma\vdash T}{\Sigma;\Gamma\vdash\Gamma,X:T}
  \end{mathpar}
  \caption{Good formation of value environments}\label{wf-valenv}
\end{figure}
\begin{figure}[ht]
  \begin{mathpar}
    \inferrule[WFModType-Arrow]{\forall 0\leq j\leq n.\quad\Sigma;\Gamma,\overline{N_i:T_i}^{i=1,\ldots,j}\vdash T_{j+1}}
              {\Sigma;\Gamma\vdash \left(\overline{N_i:T_i}^{i=1,\ldots,n}\right)\to T_{n+1}}\hfill
    \inferrule[WFModType-TArrow]{\Sigma;\Gamma,\overline{\tx:\star}\vdash T}{\Sigma;\Gamma\vdash(\overline{\tx:\star})\to T}\\
    \inferrule[WFModType-Module]{\forall \BX_i\in\overline{\BX}.\BX_i:\Lambda(\overline{\tx:\star}^i).\{\overline{D}^i\}\in\Sigma\\
      \left\{\overline{D}\right\} \preccurlyeq
        \left\{\overline{\overline{x:[=\_]}^i\;\overline{D}^i}\right\}\\
    \forall i\neq
    j.(\dom\left(\overline{D}^i\right)\#\dom\left(\overline{D}^j\right)\text{
      and } \overline{x}^i\#\overline{x}^j)\\
    \Sigma;\Gamma\vdash\overline{D}}
              {\Sigma;\Gamma\vdash\{\overline{D}\}_{\overline{\BX}}}

  \end{mathpar}
  \caption{Good formation of module system types}\label{wf-modtype}
\end{figure}

\begin{figure}[ht]
  \begin{mathpar}
  \inferrule[WFType-Core]{\\}
    {\Sigma;\Gamma\vdash\tau:\star}\hfill
  \inferrule[WFType-Union]
    {\Sigma;\Gamma\vdash t:\star\\\Sigma;\Gamma\vdash t':\star}
    {\Sigma;\Gamma\vdash t\vee t':\star}\hfill
  \inferrule[WFType-Times]
    {\Sigma;\Gamma\vdash t:\star\\\Sigma;\Gamma\vdash t':\star}
    {\Sigma;\Gamma\vdash t\times t':\star}\hfill 
  \inferrule[WFType-Function]
    {\overline{\Sigma;\Gamma\vdash t:\star}\\\Sigma;\Gamma\vdash t':\star}
    {\Sigma;\Gamma\vdash(\overline{t})\to t':\star}
    \\
    \inferrule[WFType-Record]
    {\overline{\Sigma;\Gamma\vdash t:\star}}
    {\Sigma;\Gamma\vdash \texttt{\%}\!\left\{\overline{k:t}\right\}:\star}\hfill
  \inferrule[WFType-Behaviour]
    {\BX:\Lambda(\overline{\tx:\star}).\{\overline{D}\}\in\Sigma\\
     \overline{\Sigma;\Gamma\vdash t:\star}}
    {\Sigma;\Gamma\vdash\BX[\overline{x=t}]:\star}\hfill
  \inferrule[WFType-Singleton]
    {\Sigma;\Gamma\vdash M:\texttt{mod}}
    {\Sigma;\Gamma\vdash\langle M\rangle:\star}\\
  \inferrule[WFType-Projection]
    {\\}{\\}{\text{\aghilas{We need to choose a way to consider projection in path.}}}
  \end{mathpar}
  \caption{Good formation of types}\label{wf-type}
\end{figure}

\begin{figure}[ht]
  \begin{mathpar}
    \inferrule[Path-Empty]{\\}{\\}
  \end{mathpar}
  \caption{Good formation and typing of paths}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \inferrule[Bind-DefModule]
       {\Sigma; \Gamma,\overline{\tx:\star}\vdash\overline{B}:\overline{D}\\
        \Sigma; \Gamma,\left(X:(\overline{\tx:\star})\rightarrow
        \{\overline{D}\}_\BX\right)\vdash
        \overline{B_0}:\overline{D_0}}
       {\Sigma; \Gamma\vdash(X=\Lambda(\overline{\tx:\star}).\{\overline{B}\}_{\BX}) \overline{B_0}:\left(X:(\overline{\tx:\star})\rightarrow
        \{\overline{D}\}_\BX\right)\overline{D_0}}\\
    \inferrule[Bind-Type]
       {\Sigma;\Gamma\vdash t:\star\\
        \Sigma;\Gamma, x:[=t]\vdash\overline{B}:\overline{D}}
       {\Sigma;\Gamma\vdash\left(x=\textsf{type }t\right)\overline{B}: \left(x :[=t]\right)\overline{D}}\hfill
    \inferrule[Bind-Opaque]
       {\Sigma;\Gamma\vdash t:\star\\
        \Sigma;\Gamma, x:[=t]\vdash\overline{B}:\overline{D}}
       {\Sigma;\Gamma\vdash\left(x =\textsf{opaque }t\right)\overline{B}:  \left(x:\star\right)\overline{D}}\\
    \inferrule[Bind-Empty]
       {\\}{\Sigma;\Gamma\vdash\epsilon:\epsilon}\hfill
    \inferrule[Bind-Value]
       {\Sigma;\Gamma\vdash v:\cap\overline{T}\\
        \Sigma;\Gamma,x:\cap\overline{T}\vdash\overline{B}:\overline{D}}
       {\Sigma;\Gamma\vdash\left(x=v\right)\overline{B}:
        \left(x:\cap\overline{T}\right)\overline{D}}\hfill
\inferrule[Bind-Private]
       {\Sigma;\Gamma\vdash v:\cap\overline{T}\\
        \Sigma;\Gamma,x:\cap\overline{T}\vdash\overline{B}:\overline{D}}
       {\Sigma;\Gamma\vdash\left(x=\textsf{private }v\right)\overline{B}:\overline{D}}
  \end{mathpar}
  \caption{Typing rules for bindings \fbox{$\Sigma;\Gamma\vdash\overline{B}:\overline{D}$}}
\end{figure}


\begin{figure}
  \begin{mathpar}
  \inferrule[Sub-BehMod]{\\}
    {\Sigma;\Gamma\vdash \BX\left[\overline{x=t}\right]\preccurlyeq \Sigma(\BX)\left(\overline{t}\right)}\\
  \inferrule[Sub-ModBeh]{\overline{t_i=\left\{\overline{D}\right\}_\xi.x_i}\\ \BX\in\xi}
    {\Sigma;\Gamma\vdash\left\{\overline{D}\right\}_\xi\preccurlyeq \BX\left[\overline{x_i=t_i}\right]}\hfill
  \inferrule[Sub-ModMod]{\xi'\subseteq\xi\\
    \left\{\overline{D}\right\}\preccurlyeq \left\{\overline{D'}\right\}}
            {\Sigma;\Gamma\vdash\left\{\overline{D}\right\}_\xi\preccurlyeq\left\{\overline{D'}\right\}_{\xi'}}\hfill
    \inferrule[Sub-Elixir]{t\preccurlyeq t'}{\Sigma;\Gamma\vdash t\preccurlyeq t'}\hfill
    \inferrule[Sub-Intersection]{\exists i\in I, T_i\preccurlyeq T}{\Sigma;\Gamma\vdash\cap_I\overline{T_i}\preccurlyeq T}\\
    \inferrule[Sub-BigFunction]{\forall i.\Sigma;\Gamma,X_1:R_1,\ldots, X_{i-1}:R_{i-1}\vdash T_{i}\succcurlyeq R_i\\
      \Sigma;\Gamma,\overline{X_i:R_i}\vdash T'\preccurlyeq R'}{\Sigma;\Gamma\vdash\left(X_i:T_i\right)\to T'\preccurlyeq\left(X_i:R_i\right)\to R'}
  \end{mathpar}
  \caption{Subtyping rules}
\end{figure}
}

\subsubsection{Interpreting the new types}

\paragraph{Enconding equality of types} Let $t$ be a a type, we define:
\[
\texttt{eq}(t) := (t\cup\{\mho\})\times (\neg t\cup\{\mho\}).
\]
The type $\texttt{eq}(t)$ is never empty as it contains $(\mho,\mho)$.
\begin{lemma}
  Let $t$ and $t'$ be two types, then $\texttt{eq}(t)\leq\texttt{eq}(t')$ if
  and only if $t\simeq t'$.
\end{lemma}
\subsection{Operational semantics or encoding? That's the question}

There are four possible ways to proceed from here, listed here in the order of complexity (from the simplest to the most complex):
\begin{itemize}
  \item Define an encoding of the module system into 1-ML. This would be the simplest solution. It would give both the typing and the operational semantics for free. However, it would not give a direct understanding of the module system, and it would be difficult to reason directly on it (for instance to give meaningful typing error messages).
  \item Define a type system for the module system and an encoding into 1-ML. Then prove that well typed programs are encoded into well-typed 1-ML expressions This would give a direct understanding of the module system type system, and it would be possible to reason directly on it, but the operational semantics would still be given by the encoding.
  \item Define a type system and an operational semantics for the module system and an encoding into 1-ML. Then prove that well typed programs are encoded into well-typed 1-ML expressions and that the operational semantics is simulated by the encoding. This would give a direct understanding of both the type system and the operational semantics of the module system, but it would be more complex to define and to prove. (My preference would be for this solution.)
  \item Define a type system and an operational semantics for the module system and prove type soundness directly on the module system. This would be the most complex solution, but it would give a direct understanding of both the type system and the operational semantics of the module system. It would also lack the connection with 1-ML.
\end{itemize}

\begin{figure}
  \begin{tabular}{r c ll}
    $\tau$ & ::= & $t$                 &\color{Gray} all simple types (including fully instantiated behaviours)\\
    & | & $\left(\overline{N:\tau}\right)\rightarrow \tau$ &\color{Gray} types of functions on modules\\
    & | & $\kwlike(M)$                 &\color{Gray}anonymous module type\\
    & | & $\kwbeha(M)$                 &\color{Gray}nominal behaviour type\\
    & | & $\cap\overline{\tau}$        &\color{Gray} syntactic intersection (programmer should no see any difference with the semantic one) \\
  %  & | & $X\left[\overline{\tx=t}\right]$\\
    & | & $\star$            & \color{bordeaux} I would remove this production: we do not want to pass around types do we?\\
                                      &&&\color{bordeaux} a milder form could be $(\tx:\star)\to\tau$ but do we want HO modules to be first class?\\        
                                      &&&\color{bordeaux} or fully instantiated modules only?
  \end{tabular}
  \caption{Syntax of surface module types}
\end{figure}
%\begin{figure}
%  \centering
%  \begin{tabular}{c c c c c}
%    $\kwmdl X : T$ & $\cap$ & $\kwmdl X : T'$ & = & $\kwmdl X : T\cap T'$\\
%    $\kwclbk X :\bigcap\overline{T}$ & $\cap$ & $\kwclbk X : \bigcap\overline{T'}$ & = & $\kwclbk X : \bigcap \overline{T}\,\overline{T'}$\\
%    $\kwtp x = t$ & $\cap$ & $\kwtp x = t'$ & = & $\kwtp x = t\wedge t'$\\
%    $\kwopq x$ & $\cap$ & $\kwopq x$ & = & $\kwopq x$\\
%    $\kwopq x$ & $\cap$ & $\kwtp x = t$ & = & $\kwtp x = t$\\
%    $\kwtp x = t$ & $\cap$ & $\kwopq x$ & = & $\kwtp x = t$\\
%    $D$ & $\cap$ & $D'$ & = & $\epsilon$\\
%  \end{tabular}
%  \caption{Component-wise intersection}
%\end{figure}
\section{Optional callbacks}

Explain here how to extend the module system to allow optional callbacks, that is, callbacks that are not required by the behaviour but may be implemented by the module.

\printbibliography
\end{document}

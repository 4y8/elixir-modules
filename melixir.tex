\documentclass[a4paper,10pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage[table,dvipsnames]{xcolor}
\usepackage{setup}
\usepackage[T1]{fontenc}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{inconsolata}
%\usepackage{libertine}
\usepackage{bbold}
% Add biblatex
\usepackage[style=alphabetic,backend=biber]{biblatex}
\addbibresource{biblio.bib} 


\DeclareMathOperator{\kwdefmt}{\textsf{defmodtype}}
\DeclareMathOperator{\kwend}{\textsf{end}}
\DeclareMathOperator{\kwdo}{\textsf{do}}
\DeclareMathOperator{\kwbvr}{\textsf{\$behaviour}}
\DeclareMathOperator{\kwlet}{\textsf{let}}
\DeclareMathOperator{\kwin}{\textsf{in}}
\DeclareMathOperator{\kwprm}{\textsf{\$param}}
\DeclareMathOperator{\kwdefm}{\textsf{defmodule}}
\DeclareMathOperator{\kwopq}{\textsf{\$opaque}}
\DeclareMathOperator{\kwtp}{\textsf{\$type}}
\DeclareMathOperator{\kwpr}{\textsf{\$private}}
\DeclareMathOperator{\kwmdl}{\textsf{\$module}}
\DeclareMathOperator{\kwclbk}{\textsf{\$callback}}
\DeclareMathOperator{\kwfn}{\textsf{fn}}
\DeclareMathOperator{\kwlike}{\textsf{like}}
\DeclareMathOperator{\kwint}{\textsf{int}}
\DeclareMathOperator{\struct}{\textsf{struct}}
\DeclareMathOperator{\dom}{\textsf{dom}} 
\newcommand{\tx}{\textrm{x}}
\newcommand{\BX}{\ensuremath{\mathcal{X}}}
\newcommand{\self}{\texttt{\_\_MODULE\_\_}}

\author{Aghilas Y. Boussaa and Giuseppe Castagna}
\sloppy
\begin{document}


\section{Introduction}
\beppe{Cut and paste from the Programming paper Appendix}


GenServer is a behaviour of Elixir standard library that abstracts the
common client-server interaction. It provides the boilerplate to
supervise sync and async calls. The documentation of the latest
version (v1.15.6) can be found at \url{https://hexdocs.pm/elixir/1.15.6/GenServer.html}.

A schematic description of its definition (written using Typespec)
is given next, where we use colors to highlight the
interesting parts
%\pagebreak
\begin{minted}[escapeinside=!!,fontsize=\footnotesize,baselinestretch=.9]{elixir}
defmodule GenServer do
 # Types  
 @type !\color{typeAqua}option()! :: {:debug, debug()} | {:name, name()} | ...    !\color{typeAqua}//transparent\label{001}!
 @type !\color{typeAqua}result()! :: {:reply, reply(), state()} | ...             !\color{typeAqua}//transparent\label{002}!
 @type !\color{typeBlue}state()! :: term()                                        !\color{typeBlue}//opaque\label{003}!
 @type !\color{bordeaux}request()! :: term()                                      !\color{bordeaux}//parameter\label{004}!
 @type !\color{bordeaux}reply()! :: term()                                        !\color{bordeaux}//parameter\label{005}!
    !\etc!
 # Callbacks
 @callback init(init_arg :: term()) :: {:ok, state()} | :error 
 @optional_callback handle_call(request(),pid(),state()) :: result() 
 @optional_callback handle_cast(request(),state()) :: result()       
    !\etc!
 # Functions
 @spec start(!{\color{red}module()}!, any(), options()) :: on_start()          !\color{red}//higher-order\negspace\label{009}!
    !\etc!
end
\end{minted}
Let us make some observations for each section:
\begin{itemize}
  \item \textbf{Types.} The types \elix{option()} and \elix{result()} are completely defined and  shared by all implementations of the GenServer behaviour, thus they must be transparently exported. The type \elix{state()} is the type of internal state of a server and can be manipulated only by the functions of each implementation, thus it must be opaquely exported. The types \elix{request()} and \elix{reply()} describe the messages sent for requests and replies; as for \elix{state()}, they are specific to each implementation, but they must be public so that processes can perform correct requests; therefore they are parameter of the implementations.

  \item \textbf{Callbacks.} Callbacks are either mandatory or optional. From a typing point of view this is akin to the optional and mandatory fields for map types.

  \item \textbf{Functions.} The first argument of the \elix{start} function must be a module, but in practice it cannot be any module: it must be the same module that implements the behaviour or, at least (to type-check), a module implementing exactly the same behaviour.
\end{itemize}
What do these observations imply on the definition of types? If
behaviours are to be promoted to (module) types, then we expect the
GenServer behaviour to be defined as follows (we use a mock-up syntax
combined with our types):
\begin{minted}[escapeinside=!!,fontsize=\footnotesize,baselinestretch=.9]{elixir}
defmodule !\negspace\textbf{\color{darkgreen}type}! GenServer(!{\color{bordeaux}request, reply}!) do
 # Types
 !\textcolor{typeGreen}{type}! option() = {:debug, debug()} | {:name, name()} | ...      !\color{typeAqua}//transparent!
 !\textcolor{typeGreen}{type}! result() = {:reply, !{\color{bordeaux}reply}!, state()} | ...                 !\color{typeAqua}//transparent!
 !\textcolor{typeGreen}{type}! state()                                                   !\color{typeBlue}//opaque!
    !{\etc}!
 # Callbacks
 !\textcolor{typeGreen}{callback}! init :: init_arg() -> {:ok, state()} | :error      
 !\textcolor{typeGreen}{callback}! optional(handle_call) :: !{\color{bordeaux}request}!, pid(), state() -> result() 
 !\textcolor{typeGreen}{callback}! optional(handle_cast) :: !{\color{bordeaux}request}!, state() -> result()        
    !\etc!
 # Functions
 !\textcolor{typeGreen}{spec}! start :: GenServer(!{\color{bordeaux}request, reply}!), init_arg(), options() -> on_start()!\negspace!
    !\etc!
end
\end{minted}
The types \elix{request} and \elix{reply} are now parameters of the (module) type GenServer; the types \elix{request()} and \elix{reply()} are transparently exported, while \elix{state()} is opaque. optional callbacks are explicitly declared with a syntax reminiscent of map types. Finally, the type of the  first \elix{start} function explicitly declares that the first argument of the  function must be a module of the same type as the one implemented. Notice that the second argument of \elix{start} is of type \elix{init_arg()} since this argument is then passed to the function \elix{init}. We left the definition of \elix{init_arg()} unspecified, but it should probably be yet another parameter of the GenServer behaviour, exactly as  \elix{request()} and \elix{reply()}.  



\subsection{The PoETS Proposal}
In the paper "Principles of Elixir Type System"~\cite{CDV24}, we proposed to type the Genserver example as follows

\begin{minted}[escapeinside=!!,fontsize=\footnotesize]{elixir}
defmodule!\textbf{\color{red}type}! GenServer do
  # Types
  !\textcolor{bordeaux}{\$param}! request
  !\textcolor{bordeaux}{\$param}! reply
  !\textcolor{typeGreen}{\$type}! option = {:debug, debug()} | {:name, name()} | ...        !\color{typeAqua}//transparent!
  !\textcolor{typeGreen}{\$type}! result = {:reply, !{\color{bordeaux}reply}!, state()} | ...                   !\color{typeAqua}//transparent!
  !\textcolor{typeGreen}{\$opaque}! state                                                   !\color{typeBlue}//opaque!
    !{\etc}!
  # Callbacks
  !\textcolor{typeGreen}{\$callback}! init : init_arg() -> {:ok, state} | :error      
  !\textcolor{typeGreen}{\$callback}! optional(handle_call) : !{\color{bordeaux}request}!, pid(), state -> result
  !\textcolor{typeGreen}{\$callback}! optional(handle_cast) : !{\color{bordeaux}request}!, state -> result        
    !\etc!
end

defmodule GenServer do
 # Functions
 !\textcolor{typeGreen}{\$}! (Mod : GenServer[!{\color{bordeaux}request=a, reply=b}!],  arg : init_arg(), opt : Mod.options) -> on_start() !\elabel{starttype}!
    when a: term(), b: term()
 def start(Mod, arg, opt) do
    !\etc!
end
\end{minted}
Our current proposal that we describe in the rest of this document is very similar to the above, but much more detailed and formalized.

\section{The new Elixir module system}
An Elixir program is a sequence of module definitions. When a module definition contain a \elix{@callback} declaration, this module is considered a \emph{behaviour}. Behaviours are a kind of hybrid definitions since they define both a module type and, whenever they export functions, a module value. This ambiguity is resolved by the Elixir compiler, which will generate a module \emph{type} definition for the behaviour, and a module \emph{value} definition for the implementations exported by the behaviour.

For the sake of simplicity, we will suppose that this distinction is already done in the program. In the rest of the document, then, we will suppose that a program is a sequence of module type definitions, followed by the \texttt{Main} module definition, containing just a list of bindings. 
\[\overline{\kwdefmt X \kwdo \overline{P}\, \overline{D} \kwend}\kwdefm \textit{Main} \kwdo \overline{B} \kwend\]
Intuitively, the list of bindings $\overline{B}$ exported by the module \textit{Main} will be the list of the toplevel modules definitions of the program, whose general form is as follows: 
\begin{equation}\label{eq:module}
\kwdefm X \kwdo \overline{P}\, \overline{S}\, \overline{B} \kwend
\end{equation}
With this convention, every module defined in the program is then denoted by a unique path starting with \texttt{Main} module name.

The full syntax of the surface language is given in Figure \ref{fig:surfacesyntax}. In Elixir there is a unique syntactic category for names, although developers are invited to follow the naming convention of using capitalized names for modules and (thus) behaviours. To enhance clarity, we use $x$ to range over expression variables, $X$ for module names, $\tx$ for type names, and $\BX$ for behaviour names. 


\begin{figure}
  \begin{tabular}{r c ll}
    $\mathcal B$ & ::= &$\kwdefmt \BX\kwdo \overline{P}\, \overline{D} \kwend$ \\
    $N$ & ::= & $x$ \\
    & | & $X$ \\
    $S$ & ::= & $\kwbvr \BX$ \\
    $P$ &::= & \textcolor{Cerulean}{$\kwprm \tx$} \\
    $B$ &::= & $\kwdefm X \kwdo \textcolor{Cerulean}{\overline{P}}\, \overline{S}\, \overline{B} \kwend$ \\
    & | & $x = v$\\
    & | & $\kwpr x = v$ \\
    & | & $\kwtp \tx = t$ \\
    & | & \textcolor{Cerulean}{$\kwopq \tx = t$} \\
    $M$ & ::= & $X\textcolor{Cerulean}{[\,\overline{\tx=t}\,]}$ \\ 
    & | & $X.M$ & \text{\small José version: only the last module of the path can be instantiated}\\
        & | & $\textcolor{Cerulean}{M}.M$ & \text{\small More general version: every module of the path can be instantiated}\\
$E$ &::= & $v$ \\
    & | & $x$ \\
    & | & $\kwlet N = E\kwin E$ \\
    & | & $E(\overline{E})$ \\
    & | & $\texttt{\%}\!\left\{\overline{\ell=E}\right\}$ \\
    & | & $E.\ell$ \\
    & | & $(E\in t)?E:E$ \\
    & | & $\textcolor{OrangeRed}{M.x}$ \\
    & | & $\textcolor{OrangeRed}{M}$ \\
     & | & $\textcolor{OrangeRed}{\self}$ \\
   $v$ & ::= & $c$ \\
    & | & $\texttt{\%}\!\left\{\overline{\ell=v}\right\}$ \\
    & | & $\$\bigwedge \overline{(\,\overline{\,t\,}\,)\rightarrow t} \kwfn \overline{x} \rightarrow E$ \\
    & | & \textcolor{OrangeRed}{$\$\bigcap \overline{\left(\overline{N:T}\right)\rightarrow T} \kwfn \overline{N}\rightarrow E$} \\
    $T$ & ::= & $t$ \\
    & | & $\left(\overline{N:T}\right)\rightarrow T$ \\
  %  & | & $[\overline{\tx:\star}]\to T$ & do we want this syntax or remove it and have $\left\{\overline P;\overline{S};\overline{D}\right\}$?\\
    & | & $\left\{\textcolor{Cerulean}{\overline{P}};\overline{S};\overline{D}\right\}$ & the programmer should be able to denote this type only via (\textsf{Like }$M$)\\
    $t$ & ::= & $\kwint$ \\
    & | & $\texttt{module}$ & top module type \\
    & | & $(\overline{\,t\,})\rightarrow t$\\
    & | & $\texttt{\%}\!\left\{\texttt{..., }\overline{f}\right\}$ & open record type\\
    & | & $\texttt{\%}\!\left\{\overline{f}\right\}$ & closed record type \\
    & | & $t\vee t$ \\
    & | & $t\wedge t$ \\
    & | & $\neg t$\\
    & | & $\alpha$ \\
    & | & $\mathbb{O}$ \\
    & | & $\textcolor{OrangeRed}{M.\tx}$ \\
    & | & $\textcolor{OrangeRed}{\mathcal{X}[\,\overline{\tx=t}\,]}$  & shall we move this into $T$? Consequence no $\kwtp x = \elix{Stack}$ [which seems ok]\\
    $f$ & ::= & $\ell : t$ & mandatory field {\color{bordeaux}[should we use $T$ instead of $t$? Or $\BX[\overline{\tx=t}]$? Or $\{\overline{D}\}_{\overline{\BX}}$?]}\\
    & | & $\ell \;\texttt{=>}\; t$ & optional field {\color{bordeaux}[same questions as above]}\\
    $D$ & ::= & $\kwmdl X : T$ \\
    & | & $\kwclbk x : \bigcap \overline{T}$ \\
    & | & $\kwopq \tx$ \\
    & | & $\kwtp \tx = t$\\
  \end{tabular}

  \bigskip
  In \textcolor{Cerulean}{blue} the modifications of the  current Elixir syntax.
  \caption{Syntax of the surface language }\label{fig:surfacesyntax}
\end{figure}


\subsection{Module Types}
Let us first examine the syntax of the module types declarations, which is given by the syntax, \[\kwdefmt \BX\kwdo \overline{P}\, \overline{D} \kwend\] and which correspond to the definition of a behaviour (ie., a module with callback declarations), stripped of its function definitions. The module type $\BX$ is defined by a list of type parameters $\overline{P}$, and a list of export declarations and callback declarations $\overline{D}$. Every module implementing the behaviour $\BX$ must \emph{at least} provide:
\begin{itemize}
    \item a transparent type definition of the form $\kwtp \tx = t$ for every $\kwprm \tx$ declared in $\overline{P}$,
    \item an opaque type definition of the form $\kwopq \tx = t$ for every $\kwopq \tx$ declared in $\overline{D}$,
    \item a transparent type definition of the form $\kwtp \tx = t$ for every $\kwtp \tx = t$ declared in $\overline{D}$,
    \item a definition of the form $x = v$  with $v$ of type $\bigcap\overline{T}$ for every callback $\kwclbk x : \bigcap \overline{T}$ declared in $\overline{D}$.
\end{itemize} 
For instance, a \elix{StackB} behaviour for modules wanting to implement a stack parametric in the type of its elements can be defined as follows:
\begin{minted}{elixir}
!\color{blue}defmodtype! StackB do
  !\tp!param elem
  !\tp!opaque stack
  !\tp!callback new : () -> stack
  !\tp!callback push : (stack, elem) -> stack
  !\tp!callback pop : stack -> {elem, stack}
end
\end{minted}

\subsection{Expressions}
In Figure~\ref{fig:surfacesyntax} we specified a minimal set of expressions---ranged over by $E$---to represent Elixir. The syntax is kept minimal since we want to focus on the module system. So our expressions form a simple functional language with records (in Elixir parlance ``maps'') and a type-case expression (in lieu of more general case expressions).  Elixir uses the notation $\texttt{\%}\!\left\{\overline{\ell=E}\right\}$ for records (maps) with fields $\ell$ initialized to $E$, and we reproduce it here faithfully. For type-cases we use instead the expression $(E\in t)?E_1:E_2$ which evaluates to $E_1$ or to $E_2$ according to whether $E$ returns a value of type $t$ or not; this is not valid Elixir syntax, but it serves a similar purpose. The syntax is essentially the one by~\cite{CDV24} with three notable additions (in red in the figure): $M$, denoting the module (reached by the path) $M$, \self{} which returns the name of the (innermost) current module, and $M.x$ denoting the function or constant $x$ exported by the module $M$. The other expressions are standard, though the syntax may not be familiar to the reader. In particular, functions in Elixir are prefixed by their type declaration which, in general, is an intersection of (multi-arity) arrow types. Thus, we use $\$\bigwedge_{i\in I} \overline{(\,\overline{\,t_i\,}\,)\rightarrow t_i} \kwfn \overline{x} \rightarrow E$ to denote the anonymous function of parameters $\overline{x}$, body $E$ and annotated with the intersection type $\bigwedge_{i\in I} \overline{(\,\overline{\,t_i\,}\,)\rightarrow t_i}$ meaning that when the function is applied to arguments of type $\overline{t_i}$, we expect a result of type $t_i$. Functions are values, and we notice that there are two forms of function definitions that differ by the annotation that precedes them. In red the new annotations we introduce for the module system which have the particularity that the types in the domain may be named, and that the arrows are on module types; in particular these can use the names specified for the domains (e.g., the code in line~\ref{starttype} declares that the type of the third argument of \elix{start()}, is \elix{Mod.option}, that is the \elix{option} type exported by the first argument). We will give more details in Section~\ref{sec:types}.

Let us examine in detail the definition of a module, as given in \eqref{eq:module}.

The definition of a module $X$ is a sequence of three blocks: the list $\overline P$ of type parameters of the form $\kwprm \tx$, the list $\overline S$ of behaviours declarations of the form  $\kwbvr \BX$, and the definition of the module itself, which is a sequence of bindings $\overline{B}$. In Elixir, these three blocks may be interleaved, but for the sake of simplicity we will suppose that they are grouped together in the order given above. The module type parameters are used to define the type of the module and are instantiated when the module is used; the list of behaviours specifies the behaviours that this module implements. 

The bindings $\overline{B}$ are used to define the actual implementation of the module, which may include definitions of types, values, and modules.

In a \emph{type binding}, a type $t$ is bound to a name $\tx$, and this binding may be transparent or opaque, as defined by the syntax $\kwtp \tx = t$ and $\kwopq \tx =t$ respectively. An opaque type definition makes the binding $\tx= t$ visible only inside the module, while a transparent one makes this binding visible also outside the module and is in general used to instantiate the parameters of the behaviours the module implements. Thus, for instance if the \elix{StackB} is defined as the above, then a module \elix{StackInt} implementing the behaviour for integers will be defined as
\begin{minted}{elixir}
defmodule StackInt do            # should we write all the types as stack() rather than just stack?
  !\tp!behaviour StackB                       # declare that the module implements the behaviour StackB 
  !\tp!type elem = integer()                  # instantiate the behaviour parameter
  !\tp!opaque stack = list(integer())         # define the opaque type of the stack

  # callbacks implementations
  !\tp! () -> stack
  def new(), do: []

  !\tp! (stack, elem) -> stack
  def push(s, e), do: [e|s] 

  !\tp! (stack) -> {integer(), stack}
  def pop(s), do: {hd(s), tl(s)} 
end
\end{minted}
Although the current Elixir syntax does not allow it, in the system of Figure~\ref{fig:surfacesyntax} we can also define a module to be parametric in some types. For instance, we can define the module stack to be parametric in the type of
its elements, and then pass this parameter as argument to the behaviour, as in
the following example, in which we add a  \elix{top} function and  a
higher-order function \elix{move}
\begin{minted}{elixir}
defmodule StackModule do
  !\tp!param elem
  !\tp!behaviour StackB
  !\tp!type elem = elem              # instantiate the behaviour parameter with the module parameter
  !\tp!opaque stack = list(elem)

  # callbacks implementations
  !\tp! () -> stack
  def new(), do: []

  !\tp! (stack, elem) -> stack
  def push(s, e), do: [e|s] 

  !\tp! (stack) -> {integer(), stack}
  def pop(s), do: {hd(s), tl(s)} 

  # extra functions
  !\tp! (stack) -> elem
  def top(s), do: hd(s)

  !\tp! (X: StackB[elem=elem], sx: X.stack, Y: StackB[elem=elem], sy: Y.stack) -> Y.stack
  def move(X, sx, Y, sy) do: Y.push(sy,X.top(sx))
\end{minted}
Now the module \elix{StackModule} is parametric in the type of its elements, and to use it we must instanciate as in \elix{StackModule[elem=integer()].new()} which returns a value of (opaque) type \elix{StackModule[elem=integer()].elem}.

\begin{remark} In order to reduce verbosity on can imagine using the aliasing mechanism of Elixir to define a shorter name for the module type \elix{StackB[elem=integer()]} as in
%\begin{minted}{elixir}

\elix{alias StackModule[elem=integer()], as: StackMInt}

%\end{minted}
\noindent
and then use \elix{StackMInt.new()} to create a new stack of integers.\hfill$\square$
\end{remark}

In a \emph{value binding}, a value $v$ is bound to a name $x$ which may be exported or private, as defined by the syntax $x = v$ and $\kwpr x = v$ respectively. In general, a value $v$ is either a constant of some basic type, or a record of constants, or a function. In the latter case, the function is defined in Elixir by the syntax \elix{def} and \elix{defp} for exported and private functions respectively, and prefixed by their type annotations as in the following example:
\begin{minted}{elixir}
defmodule X do
  !\tp! (!$t_1$! -> !$t_2$!) and (!$t_3$! -> !$t_4$!)
  def f(x,y), do: !$E_1$! 

  !\tp! (X : StackB[elem=integer()], s: X.stack) -> integer()
  defp g(X,s), do: !$E_2$!
end  
\end{minted}
The above examples are considered as syntactic sugar and in the syntax of Figure \ref{fig:surfacesyntax} are rendered by the following definitions 
\begin{minted}{elixir}
defmodule X do
  f = !\tp$(t_1\to t_2) \wedge (t_3 \to t_4)$! fn x, y -> !$E_1$!
  g = !\tp!private !\tp!(X : StackB[elem=int], s: X.stack) !$\to$! int fn X, s -> !$E_2$!
end
\end{minted}

Finally, a \emph{module binding} is a simple definition of the form $\kwdefm X \kwdo \overline{P}\, \overline{S}\, \overline{B} \kwend$  as in \eqref{eq:module}, and binds the module name $X$ with its definitions.


\subsection{The consequences of parametric modules}
While having parametric behaviours is quite straightforward, the addition of parametric modules has several consequences on the syntax and semantics of the module system.


\paragraph{Syntax.} The first important consequence is that this requires an important modification of the current Elixir syntax. If we just allow parametric behaviours and not also parametric modules, then the modification of the syntax of the expressions is really minimal: while currently a module definition just defines types (e.g., \elix{@type state() :: term()}) the new type definitions of a module expression must specify for each type definition whether this type is exported transparently (i.e., both name and definition: $\kwtp \tx = t$) or opaquely (i.e., just its name: $\kwopq \tx = t$), and nothing else for what concerns the expression syntax (in particular modules with this choice are denoted by paths of module identifiers: $X_1.X_2.\cdots{.}X_n$, just like in current Elixir).

If we also allow parametric modules, then we must extend the syntax of module expressions to declare the parameters $\overline P$ in the form $\kwprm \tx$ (easy), but \textbf{above all} we have to change the syntax of paths to allow instantiations of the parameters of modules. This is done by the syntax $X[\overline{\tx=t}]$ denoting the module $X$ instantiated with the types $\overline{t}$ for its parameters $\overline{\tx}$. 
There are two possible syntaxes for paths with instantiations.
\begin{enumerate}
\item The instantiation may occur at any level of a path, as in $X_1[\overline{\tx=t}].X_2[\overline{\tx=t}].X_3[\overline{\tx=t}]$, or
\item The instantiation can only occur at the end of the path, as in $X_1.X_2.X_3[\overline{\tx=t}]$, that is for the innermost module only.
\end{enumerate}
 The former is more general (and it can be easily encoded in 1ML), but can be quite demanding to the programmer especially if the system requires all parametric modules in a path to be explicitly syntactic sugar.


 The latter is simpler, it reflects the current implementation of Elixir, where the nesting of modules is just a syntactic facility since all modules are flat and the nesting is handled by the compiler by naming each nested module with the full and unique path to it. This however imposes to carefully define the scoping rules of types in a module. In particular:
 \begin{itemize}  
  \item the parameters of a module $X$ are not visible in the modules nested in $X$;
  \item a type $\tx$ defined in a module $X$ is visible in all modules nested in $X$ only if all the types used in the definition of $\tx$ are visible in the nested modules.
  \item a value $x$ defined in a module $X$ is visible in all modules nested in $X$ only if all the types used in the type of $x$ are visible in the nested modules.
 \end{itemize}
 This implies that to use a type or a value non-visible in a nested module, we must use a full and explicitly (and terminally) instantiated path to denote it.
 Actually this is completely in line with the current Elixir implementation, where nested modules do not have access to the types and values defined in their enclosing module(s), unless these are explicitly denoted by their full path.

The reader may have noticed that we used a different color in three terms of the syntax: the parameters $\kwdefm X \kwdo \textcolor{Cerulean}{\overline{P}}\, \overline{S}\, \overline{B} \kwend$ in module definitions; the type of modules $\left\{\textcolor{Cerulean}{\overline{P}};\overline{S};\overline{D}\right\}$; the instantiation $X\textcolor{Cerulean}{[\,\overline{\tx=t}\,]}$ in module denotations. The colored syntax denotes all the modifications to the syntax of Elixir \textbf{expressions} that are needed to implement parametric modules. In the current  Elixir expression syntax, a module is denoted only by its name since there are no parametric modules, therefore no parameter instantiation: paths are only of the form \elix{Mod1.Mod2.Mod3} rather than, say, \elix{Mod1[x=integer()].Mod2.Mod2[z=proc()]} (in the variant that corresponds to $M::= M.M \mid X[\overline{\tx=t}]$), or its terminal variant \elix{Mod1.Mod2.Mod2[z=proc()]} (corresponding to $M::= X.M\mid X[\overline{\tx=t}]$)

If do not want to extend the current Elixir syntax for expressions to allow parametrized modules such as \elix{StackModule}, it suffices to remove the syntax colored in blue  from Figure~\ref{fig:surfacesyntax}, that is, instantiations in module, and the type parameters in module types and definitions (the two definitions of paths in that case collapse).\footnote{Of course, we will still replace Typespec specifications with our new syntax for types.} Then all the modifications to type the Elixir module system will be confined to types and type-related definitions, and the expressions will remain unchanged. In particular, type parameters will be confined to behaviours. 


\paragraph{Inference.} A second important consequence of parametric modules is that we have to decide how much inference we want to (and can) do for the type arguments of a parametrized module. This is more a matter of programming style than of formalization, though the choice may have some consequences on the formalization.
In the example of \elix{StackModule} above, for instance, we have to decide whether we want the programmer to always specify the type parameters of a module when this is used, as in \elix{StackModule[elem=integer()].new()}, or whether we want the system to be able to infer the type parameters from the context, as in \elix{StackModule.push(StackModule.new(),5)}. The latter is more convenient for the programmer, but requires a more complex type system. In particular, it requires a form of local type inference, since the type of \elix{StackModule.new()} must be inferred to be \elix{StackModule[elem=integer()].stack} from the context in which it is used (the first argument of \elix{push}). 

The easy way is to always require the programmer to specify the type parameters of a module when this is used and extend the aliasing mechanism of Elixir to allow the programmer to define local aliases for instantiated modules, as in
\begin{minted}{elixir}
defmodule MyApp do
  alias StackModule[elem=integer()], as: IntStack
  s = IntStack.new()
  s1 = IntStack.push(s,5)
end
\end{minted}
This is simpler to formalize, but may be a bit too demanding for the programmer.



\subsection{Types}\label{sec:types}

The types for expressions are strictly stratified. There are the simple types, ranged over by $t$ which are essentially  those of \cite{CDV24} with a single syntactic extension, $M.\tx$ denoting the simple type exported by the module $M$ as $\tx$. 
%
%
\beppe{If we want this strict stratification we have to 
\begin{itemize} \item Move behaviours into $T$. The consequence of this is that we cannot have a type binding of the form  $\kwtp \tx ={\BX}[\,\overline{\tx= t}\,]$, that is, a module cannot export a module type. I do not see any other consequence.
  \item this also means that we cannot have maps (and products if included) containing modules. If we want to have it we can modify the definition of field types $f$ so that the map labels to $T$, rather than $t$. The problem however is how to define union and intersections of map types with $T$ fields, since unions and intersections are not defined on $T$. As long as we do not have a semantic interpretation of $T$ we should mix syntactic and semantic subtyping.
  \item A possible intermediate solution could be to have map types to specify intersections of instantiated behaviours, $\bigcap\overline{\BX[\,\overline{\tx= t}\,]}$ as these can be considered as new basic types (modulo the ordering of the parameter instatiations) for which it is easy to define semantic subtyping. \end{itemize}}
  %
  
  On the top of the simple types there are the module system types, ranged over by $T$, which are either (fully instantiated) behaviours $\BX[\,\overline{\tx= t}\,]$, or (anonymous) module types of the form $\left\{{\overline{P}};\overline{S};\overline{D}\right\}$,\footnote{
  Programmer will not have the possibility to write this type. We are rather oriented to allow the programmer only to specify in types either some behaviour names (e.g., \felix{StackB[elem=integer()]}), or use the \texttt{Like$\;M$} syntax (e.g., \felix{Like StackInt} to denote the anonymous type of the \felix{StackInt} module.} or  the types of functions working on modules, of the form $(N_1{:} T_1,\cdots, N_n{:}T_n) \to T_{n+1}$, where $N_i$ is a parameter name, and $T_i$ is a module system type in which the names $N_j$ for $j<i$ may occur (e.g. \elix{(X : StackB[elem=integer()], s : X.stack) -> X.elem}).

  These module system types have the following intended meaning:
  \begin{itemize}
    \item A module $X$ has a behaviour type $\BX[\,\overline{\tx= t}\,]$ if it explicitly implements the behaviour $\BX$ instantiated with the types $\overline{t}$ for its parameters $\overline{\tx}$. This means that that the definition of the module $X$ contains the declaration $\kwbvr \BX$, a transparent type definition $\kwtp \tx_i=t_i$ for each  $\tx_i, t_i$, in $\overline{\tx}, \overline t$, and provides a definition for all the values, modules, and callbacks declared in $\BX$, with the types declared in $\BX$. 
    \item The type of a module is defined by the syntax $\left\{\overline{P};\overline{S};\overline{D}\right\}$, where $\overline{P}$ are the type parameters of the module, $\overline{S}$ is the list of behaviours implemented by the module, and $\overline{D}$ is a type environment, that is, the list of the typings of the definitions exported by the module. These typings are of the form $\kwmdl X : T$ for modules, $\kwclbk x : \bigcap \overline{T}$ for value definitions (constant, record values, and functions/callbacks), $\kwopq \tx$ for opaque types, and $\kwtp \tx = t$ for transparent types (of course, no type for private definitions). This list must contain at least the typings for all the type parameters and the callbacks of the behaviours $\overline{S}$ implemented by the module. The usual restrictions of Elixir apply: a module cannot implement two  behaviours with a common callback. 
    \item The type $(N_1{:} T_1,\cdots, N_n{:}T_n) \to T_{n+1}$ is used to type functions working on modules. The parameters $N_i$ are names that can be used in the types $T_j$ for $j>i$ to denote types exported by the module passed as $i$-th argument (e.g., the \elix{move} function of the \elix{StackModule} example above, which has type \elix{(X : StackB[elem=elem], sx : X.stack, Y : StackB[elem=elem], sy : Y.stack) -> Y.stack}.)
\end{itemize}

  One of the consequences of this stratification---actually, its main motivation---is that set-theoretic type connectives such as $\vee$, $\wedge$, and $\neg$ are not allowed in module system types, but only in simple types. The reason is that we do not have a semantic interpretation of the $T$ types and therefore we cannot define the set-theoretic connectives on them.


  In practice, however we need intersection types on module system types in at least two cases: when we want to define a module $M$ that implements several behaviours (since the type of the module is its anonymous type $\texttt{Like}\,M$ intersected with its properly instantiated behaviours), and when we want to define a multiclause function in which some clauses are defined for module system types (we expect the function to have an intersection of $(\overline{N:T})\to T$ arrows). Both cases are represented in the syntax of Figure~\ref{fig:surfacesyntax} by handling them syntactically. A module system type $\left\{\overline{S};\overline{D}\right\}$ represent the intersection of the anonymous type $\left\{\overline{D}\right\}$ with the behaviours $\overline{S}$, instantiated as indicated in $\overline{D}$. This will be clearer in the formalization where module types have the form $\{\overline{D}\}_{\overline{\BX}}$ to be interpreted as the syntactic intersection $\{\overline D\}\cap{\BX_1}\cap...\cap{\BX_n}$. For the second case, we use the syntax $\bigcap \overline{T}$ to declare callback types and annotate exported functions. We use $\bigcap$, rather than $\bigwedge$ to stress that this is an intersection different from the one on simple types, the former being defined syntactically (via some explicit subtyping rules), the latter semantically (via a set theoretic interpretation of types).

  ...\textbf{TO BE CONTINUED}




\section{Formalization of the module system}

\subsection{Syntax}

For our formalization we will use a slightly different syntax, which is more convenient for the type system we will define. This syntax  is given in Figure \ref{fig:modulelangsyntax}. 
\begin{figure}
  \begin{tabular}{r c ll}
    $\mathcal B$ &::= &  $\!\!\BX: \Lambda(\overline{\tx:\star}).\{\overline{D}\}$ &\color{Gray} behaviour $\BX$ with parameters $\overline \tx$\\
    $B$ &::= &  $\!\!X = \textcolor{Cerulean}{\Lambda(\overline{\tx:\star}).}\{\overline{B}\}_{\overline{\mathcal{X}}}$ &\color{Gray} module $X$ with parameters $\overline \tx$ implementing $\overline{\BX}$\\
    & | & $x = v$                                   &\color{Gray} exported definition \\
    & | & $x = \textsf{private }v$                  &\color{Gray} private definition\\
    & | & $\tx = \textsf{type }t$                     &\color{Gray} transparent type or behaviour argument\\
    & | & $\tx = \textsf{opaque }t$                   &\color{Gray} opaque type\\[3mm]
    $M$ & ::= & $X\textcolor{Cerulean}{[\,\overline{\tx=t}\,]}$                 &\color{Gray} local module\\
    & | & $M.M$                                     &\color{Gray} imported module\\
    & | & $X.M$                                     &\color{Gray} [alternative:] simplified imported module\\[3mm]
   $N$ & ::= & $x$ \\
    & | & $X$ \\[3mm]
   $E$ &::= & $v$ \\
    & | & $x$ \\
    & | & $\kwlet N = E\kwin E$ \\
    & | & $E(\overline{N})$ \\
    & | & $\texttt{\%}\!\left\{\overline{\ell=E}\right\}$ \\
    & | & $E.\ell$ \\
    & | & $(E\in t)?E:E$ \\
    & | & {\color{OrangeRed}\text{$M.x$}} \\
    & | & {\color{OrangeRed}\text{$M$}} \\
    $v$ & ::= & $c$ \\
    & | & $\texttt{\%}\!\left\{\overline{\ell=v}\right\}$ \\
    & | & $\$\bigwedge \overline{(\,\overline{t}\,)\rightarrow t} \kwfn \overline{x} \rightarrow E$ \\
    & | & {\color{OrangeRed} \text{$\$\bigcap \overline{\left(\overline{N:T}\right)\rightarrow T} \kwfn \overline{N}\rightarrow E$}} &\color{OliveGreen} syntactic intersection\\[3mm]
    $T$ & ::= & $t$ \\
    & | & $\left(\overline{N:T}\right)\rightarrow T$ \\
    & | & $\left\{\overline{D}\right\}_{\overline{\BX}}$ &{\color{OliveGreen} syntactic intersection: $\{\overline{D}\}\cap{\BX_1}\cap...\cap{\BX_n}$}: ($\BX$'s instantiations given in $\overline{D}$)\\
    & | & $\textcolor{Cerulean}{(\overline{\tx:\star})\to T}$        & \text{we can include this case in the above by adding $\star$ to $T$ and $\tx$ to $N$} \\
    & | & $\star$ &\text{\small I would remove this production: we do not want to pass around modules unless}\\
                  &&&\text{\small they are fully instantiated} $f(X:(\tx:\star)\to ...)\to ...X[\tx=\textsf{int}] ...$\\
    $t$ & ::= & $\kwint$ \\
    & | & $\texttt{module}$ & top module type \\
    & | & $(\overline{\,t\,})\rightarrow t$\\
    & | & $\texttt{\%}\!\left\{\overline{f}\right\}$ \\
    & | & $t\vee t$ \\
    & | & $t\wedge t$ \\
    & | & $\neg t$\\
    & | & $\alpha$ \\
    & | & $\mathbb{O}$ \\
    & | & \textcolor{OrangeRed}{\text{$M.\tx$}}                          &\color{Gray} the type $\tx$ imported from module $M$\\
    & | & \textcolor{OrangeRed}{\text{$\mathcal{X}[\overline{\tx=t}]$}}  &\color{Gray} a behaviour \beppe{Should it be moved to $T$? If not need semsub for it}\\
    &&&\color{bordeaux} very interesting: this allows map fields to contain modules!\\[3mm]
    $D$ & ::= & $X : T$                               &\color{Gray} exports a module $X$ of type $T$\\
    & | & $x : \bigcap \overline{T}$                  &\color{Gray} exports a value $x$ of type $\bigcap\overline T$ \\
    & | & $\tx : \star$                                 &\color{Gray} exports an opaque type $x$\\  
    & | & $\tx : [=t]$                                  &\color{Gray} exports a transparent type $x = t$  \\[3mm]
    $\Gamma$ & ::= & $\overline{D}$ &\color{Gray} type environment\\
    $\Sigma$ & ::= & $\overline{\mathcal B}$ &\color{Gray} behaviour environment\\[4mm]
  \end{tabular}

 where $\BX$ ranges over behaviour names, $X$ over module names, $x$ over variable names, $\tx$ over type names, and $\ell$ over map keys. 
  \caption{Module language syntax}\label{fig:modulelangsyntax}
\end{figure}



The main differences with respect to the Elixir syntax are the following:

\begin{enumerate}
  \item The module type $\kwdefmt \BX\kwdo \overline{\kwprm \tx}\, \overline{D} \kwend$ is written as $\BX: \Lambda(\overline{\tx:\star}).\{\overline{D}\}$.
  \item The module definition $\kwdefm X \kwdo \overline{\kwprm \tx}\; \overline{\kwbvr \mathcal{X}}\; \overline{B} \kwend$ is written as $X = \Lambda(\overline{\tx:\star}).\{\overline{B}\}_{\overline{\mathcal{X}}}$
  \item We changed the syntax of module binding so that all the bindings are of the form (\emph{name $=$ definition}): this is the main motivation for the change of syntax in point 1 above.
  \item Likewise, the types of module bindings has been modified so that all the binding are of the form (\emph{name $:$ definition-type}). This is the main motivation for the change of syntax in point 2 above.
  \item Expression can be applied only to a list of names, and not to arbitrary expressions. It is however easy to encode the expression $E_0(E_1,...,E_n)$ as $\kwlet N_1 = E'_1 \kwin ... \kwlet N_n=E'_n\kwin E'_0(N_1,\dots,N_n)$, where $E'_i$ is the encoding of expression $E_i$, and $N_i$ are fresh names.  
\end{enumerate}

\subsection{Types}

Types are either the simple types $t$, or the module system types $T$. We have already discussed the syntax and intended meaning of these types before, therefore we will not repeat it here. Here the important point is that we have to define type containment. In other words, we have to define a semantic interpretation of the simple types $t$ and a syntactic subtyping relation on module system types $T$. 

\subsubsection{Semantic subtyping for simple types}
The semantic interpretation of simple types $t$ is essentially the same as in \cite{CDV24,CD25}, with the addition of the two new forms $M.\tx$ and $\BX[\overline{\tx=t}]$. The first denotes the type $\tx$ exported by the module $M$, while the second denotes the behaviour $\BX$ instantiated with the types $\overline{t}$ for its parameters $\overline{\tx}$.

Let us start with the interpretation of $\BX[\overline{\tx=t}]$. Notice that we can deal with the type \texttt{module}, the top module type, in the same way as we did for \texttt{atom} in \cite{CD25}, as it can be considered as the infinite union of all the singleton types that form it. In the case of \texttt{atom} the singleton types are the single atoms. In the case of \texttt{module} the singleton types are all the fully instantiated behaviours, modulo the equivalence of their instantiation. Then every type contained in \texttt{module} is either a finite or a cofinite union of fully instantiated behaviours.
Therefore, we can define the interpretation of $\BX[\overline{\tx=t}]$ as the set containing all the equivalent instantiations of the behaviour $\BX$, where $\BX[\overline{\tx=t}]\simeq\BX[\overline{\tx=t'}]$ iff for every $\tx_i=t_i$, we have $t_i\simeq t'_i$ (the order of the parameters does not matter, just their names and instantiations).

For what concerns the interpretation of $M.\tx$, we can always use the type of the module names that form $M$ to deduce the simple type $M.\tx$ denotes. This is either a transparent type $t$, in which case we can define the interpretation of $M.\tx$ as the interpretation of the type $t$, or it is an opaque type, in which case we consider $M.\tx$ as a type variable (modulo the equivalence of paths defined in Figure~\ref{fig:pathequivalence}).


\subsubsection{Syntactic subtyping for module system types}
The subtyping relation on module system types $T$ is defined syntactically, since we do not have a semantic interpretation of these types. The main rules are the following:

\paragraph{Type good formation.} First of all we have to define when a module system type $T$ is well formed. This is done by the rules in Figure~\ref{fig:wftypes}, which essentially check the following conditions: $(1)$ behaviours are completely instantiated (by well-formed types); $(2)$ a path $M.\tx$ points to a type; $(3)$ in a function type $(\overline{N:T})\to T'$, the names $N_i$ are  used only in the types $T_j$ for $j>i$; $(4)$ in a module type $\{\overline{D}\}_{\overline{\BX}}$, the definitions $\overline{D}$ must contain at least the definitions of all the parameters and callbacks of the behaviours $\overline{\BX}$, instantiated as indicated in $\overline{D}$. 


\subsection{Operational semantics or encoding?}
\begin{figure}
  \begin{tabular}{r c ll}
    $\tau$ & ::= & $t$                 &\color{Gray} all simple types (including fully instantiated behaviours)\\
    & | & $\left(\overline{N:\tau}\right)\rightarrow \tau$ &\color{Gray} types of functions on modules\\
    & | & $\kwlike(M)$                 &\color{Gray}anonymous module type\\
    & | & $\cap\overline{\tau}$        &\color{Gray} syntactic intersection (programmer should no see any difference with the semantic one) \\
  %  & | & $X\left[\overline{\tx=t}\right]$\\
    & | & $\star$            & \color{bordeaux} I would remove this production: we do not want to pass around types do we?\\
                                      &&&\color{bordeaux} a milder form could be $(\tx:\star)\to\tau$ but do we want HO modules to be first class?\\        
                                      &&&\color{bordeaux} or fully instantiated modules only?
  \end{tabular}
  \caption{Syntax of surface module types}
\end{figure}
%\begin{figure}
%  \centering
%  \begin{tabular}{c c c c c}
%    $\kwmdl X : T$ & $\cap$ & $\kwmdl X : T'$ & = & $\kwmdl X : T\cap T'$\\
%    $\kwclbk X :\bigcap\overline{T}$ & $\cap$ & $\kwclbk X : \bigcap\overline{T'}$ & = & $\kwclbk X : \bigcap \overline{T}\,\overline{T'}$\\
%    $\kwtp x = t$ & $\cap$ & $\kwtp x = t'$ & = & $\kwtp x = t\wedge t'$\\
%    $\kwopq x$ & $\cap$ & $\kwopq x$ & = & $\kwopq x$\\
%    $\kwopq x$ & $\cap$ & $\kwtp x = t$ & = & $\kwtp x = t$\\
%    $\kwtp x = t$ & $\cap$ & $\kwopq x$ & = & $\kwtp x = t$\\
%    $D$ & $\cap$ & $D'$ & = & $\epsilon$\\
%  \end{tabular}
%  \caption{Component-wise intersection}
%\end{figure}
\begin{figure}
  \begin{mathpar}
    \inferrule[ElEnv-Empty]{\\}{\Sigma;\Gamma\vdash\epsilon}\hfill
    \inferrule[ElEnv-Expr]{\Sigma;\Gamma\vdash t:\star}{\Sigma,\Gamma\vdash x:t,\Gamma}\hfill
    \inferrule[ElEnv-Type]{\Sigma;\Gamma\vdash t:\star}{\Sigma;\Gamma\vdash x=t,\Gamma}\\
    \inferrule[ModEnv-ModuleType]
      {\Sigma;\Gamma,\overline{x:\star}\vdash\left\{\overline{D}\right\}}
      {\Sigma;\Gamma\vdash X=\overline{x}\mapsto\overline{D},\Sigma}\hfill
    \inferrule[ModEnv-Empty]{\\}{\Sigma;\Gamma\vdash\epsilon}\hfill
    \inferrule[ModEnv-Module]
      {\Sigma;\Gamma,\overline{x:\star}\vdash\left\{;\overline{B}\right\}}
      {\Sigma;\Gamma\vdash X=\overline{x}\mapsto\overline{B},\Sigma}\\
  \end{mathpar}
  \caption{Formation rules for environments}
\end{figure}
\begin{figure}
  \begin{mathpar}
    \inferrule[EqPath-Empty]{\\}{\Sigma;\Gamma\vdash\epsilon\cong\epsilon}\hfill
    \inferrule[EqPath-Add]
      {\Sigma;\Gamma\vdash M_1\cong M_2\\\forall i.\Sigma,\Gamma\vdash t_i\cong t'_i}
      {\Sigma;\Gamma\vdash M_1.X\left[\overline{x_i=t_i}\right] \cong
        M_2.X\left[\overline{x_i=t'_i}\right]}\\
  \end{mathpar}
  \caption{Rules for path equivalence}\label{fig:pathequivalence}
\end{figure}
\begin{figure}
  \begin{mathpar}
      \inferrule[WF-Behave]{\Sigma;\Gamma\vdash \BX :
        \overline{\tx:\star}\to \{D\} \\ \Sigma;\Gamma\vdash t_i:\star}
                {\Sigma;\Gamma\vdash \BX[\overline{\tx_i=t_i}]}
                
    \inferrule[WF-ExportType]{\Sigma;\Gamma\vdash M :
      \left\{\kwtp \tx = t\right\}\cup
      \left\{\kwopq \tx\right\}}
              {\Sigma;\Gamma\vdash M.\tx}\hfill
    \inferrule[WF-Star]{\Sigma;\Gamma\vdash}
              {\Sigma;\Gamma\vdash\star}\\
    \inferrule[WF-Function]{\Sigma;\Gamma\vdash\\
    \forall 0\leq j\leq n.\Sigma;\Gamma,\overline{N_i:T_i}^{i=1,\ldots,j}\vdash T_{j+1}}
              {\Sigma;\Gamma\vdash \left(\overline{N_i:T_i}^{i=1,\ldots,n}\right)\to T_{n+1}}\\
    \inferrule[WF-ModuleTypeNames]{\forall S_i\in\overline{S}.\Sigma(S_i)=\overline{x:\star}^i\mapsto \overline{D}^i\\
      \left\{\overline{D}\right\} \preccurlyeq
        \left\{\overline{\overline{x:[=\_]}^i\;\overline{D}^i}\right\}\\
    \forall i\neq
    j.(\dom\left(\overline{D}^i\right)\#\dom\left(\overline{D}^j\right)\text{
      and } \overline{x}^i\#\overline{x}^j)\\
    \Sigma;\Gamma\vdash\left\{\overline{D}\right\}}
              {\Sigma;\Gamma\vdash\left\{\overline{S};\overline{D}\right\}}\left(S\neq\epsilon\right)\\
    \inferrule[WF-ModuleTypeModule]{\Sigma;\Gamma\vdash T\\\Sigma;\Gamma,X:T\vdash\left\{\overline{D}\right\}}
              {\Sigma;\Gamma\vdash\left\{(\kwmdl X:T)\overline{D}\right\}}\hfill
    \inferrule[WF-ModuleTypeOpaque]{\Sigma;\Gamma,x:\star\vdash\left\{\overline{D}\right\}}
              {\Sigma;\Gamma\vdash\left\{(\kwopq x)\overline{D}\right\}}\\
    \inferrule[WF-ModuleTypeType]{\Sigma;\Gamma\vdash t\\\Sigma;\Gamma,x:[=t]\vdash\left\{\overline{D}\right\}}
              {\Sigma;\Gamma\vdash\left\{(\kwtp x = t)\overline{D}\right\}}\hfill
    \inferrule[WF-ModuleTypeCallback]{\overline{\Sigma;\Gamma\vdash T}\\\Sigma;\Gamma,x:\bigcap\overline{T}\vdash\left\{\overline{D}\right\}}
              {\Sigma;\Gamma\vdash\left\{(\kwclbk x:\bigcap\overline{T})\overline{D}\right\}}
  \end{mathpar}
  \beppe{Change WF-ModuleTypeNames for the new syntax $\{\overline{D}\}_{\overline{\BX}}$}
  \caption{Well-formedness rules for types \fbox{$\Sigma;\Gamma\vdash T$}}\caption{fig:wftypes}
\end{figure}
\begin{figure}
  \begin{mathpar}
    \inferrule[Bind-DefModule]
       {\Sigma; \Gamma,\overline{P:\star}\vdash\overline{B}:\overline{D}\\
        \Sigma; \Gamma,X:\left(\overline{P:\star}\right)\rightarrow
        \left\{\overline{S};\overline{D}\right\}\vdash
        \overline{B_0}:\overline{D_0}}
       {\Sigma; \Gamma\vdash\left(\kwdefm X\kwdo \overline{P}\overline{S}\overline{B}
        \kwend\right) \overline{B_0}:\left(X:\left(\overline{P:\star}\right)\rightarrow
        \left\{\overline{S};\overline{D}\right\}\right)\overline{D_0}}\\
    \inferrule[Bind-Type]
       {\Sigma;\Gamma\vdash t:\star\\
        \Sigma;\Gamma, x:[=t]\vdash\overline{B}:\overline{D}}
       {\Sigma;\Gamma\vdash\left(\kwtp x=t\right)\overline{B}: \left(x :[=t]\right)\overline{D}}\\
    \inferrule[Bind-Opaque]
       {\Sigma;\Gamma\vdash t:\star\\
        \Sigma;\Gamma, x:[=t]\vdash\overline{B}:\overline{D}}
       {\Sigma;\Gamma\vdash\left(\kwopq x = t\right)\overline{B}:  \left(x:\star\right)\overline{D}}\\
    \inferrule[Bind-Empty]
       {\\}{\Sigma;\Gamma\vdash\epsilon:\epsilon}\hfill
    \inferrule[Bind-Value]
       {\Sigma;\Gamma\vdash v:\cap\overline{T}\\
        \Sigma;\Gamma,x:\cap\overline{T}\vdash\overline{B}:\overline{D}}
       {\Sigma;\Gamma\vdash\left(x=v\right)\overline{B}:
        \left(x:\cap\overline{T}\right)\overline{D}}
  \end{mathpar}
  \caption{Typing rules for bindings \fbox{$\Sigma;\Gamma\vdash\overline{B}:\overline{D}$}}
\end{figure}
\begin{figure}
  \begin{mathpar}
    \inferrule[Path-Empty]{\\}{\Sigma;\Gamma\vdash\epsilon:\{\epsilon;\Gamma\}}\\
    \inferrule[Path-SubModule]{\Sigma;\Gamma\vdash P:\left\{\_;\overline{D}\right\}\\
      \overline{D} = \ldots, \kwdefm X\kwdo\overline{P}\overline{S} \overline{B} \kwend ,\ldots \\
      \overline{P} = \overline{\kwprm x}\\
      \Sigma;\Gamma\vdash\overline{t}
    }{\Sigma;\Gamma\vdash P.X\left[\overline{x=t}\right]:\left\{\overline{S} ; \overline{\kwtp x=t}\, \overline{B} \right\}}
  \end{mathpar}
  \caption{Well-formdness rules for paths}
\end{figure}
\begin{figure}
  \begin{mathpar}
    \inferrule[Type-Variable]{\Sigma;\Gamma\vdash P:\left\{\overline{S};\overline{D} (x:\cap T)\overline{D'}\right\}}{\Sigma;\Gamma\vdash P.x : \cap T}\\
    \inferrule[Type-Subsumption]{\Sigma;\Gamma\vdash T\\ \Sigma;\Gamma\vdash E : \cap\overline{T'}\\ \Sigma;\Gamma\vdash\cap\overline{T'}\preccurlyeq T}{\Sigma;\Gamma\vdash E : T}
    \\
    \inferrule[Type-BigFunction]
        {\Sigma;\Gamma\vdash\cap\overline{\overline{N:T}\to T'} \and \overline{\Sigma;\Gamma,\overline{N:T}}\vdash E:T'}
        {\Sigma;\Gamma\vdash\$\cap\overline{\forall\overline{\alpha}\left(\overline{N:T}\right)\to T'}\kwfn \overline{N}\to E:\cap\overline{\overline{N:T}\to T'}}\\
    \inferrule[Type-Module]{\Sigma;\Gamma\vdash P:\left\{\overline{S_0};\overline{D_0}
      (X:\overline{y:\star}\to\left\{\overline{S};\overline{D}\right\})
      \overline{D_1}\right\}\\
      \Sigma;\Gamma\vdash\overline{t}\\
      \overline{x}\simeq\overline{y}
    }{\Sigma;\Gamma\vdash P.X\left[\overline{x=t}\right]:\left\{\overline{S};\overline{D}\right\}}
  \end{mathpar}
  \caption{Typing rules for the surface language}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \inferrule[Sub-StarRefl]{\\}{\star\preccurlyeq\star}\hfill
    \inferrule[Sub-Elixir]{t\preccurlyeq t'}{\Sigma;\Gamma\vdash t\preccurlyeq t'}\hfill
    \inferrule[Sub-Intersection]{\exists i\in I, T_i\preccurlyeq T}{\Sigma;\Gamma\vdash\cap_I\overline{T_i}\preccurlyeq T}\\
    \inferrule[Sub-ModuleLeft]{\Sigma;\Gamma\vdash P:\left\{\overline{S};\overline{D} (x:[=t])\overline{D'}\right\}\\ \Sigma;\Gamma\vdash t\preccurlyeq T}{\Sigma;\Gamma\vdash P.x\preccurlyeq T}\\
    \inferrule[Sub-ModuleRight]{\Sigma;\Gamma\vdash P:\left\{\overline{S};\overline{D} (x:[=t])\overline{D'}\right\}\\ \Sigma;\Gamma\vdash \cap\overline{T}\preccurlyeq t}{\Sigma;\Gamma\vdash\cap\overline{T}\preccurlyeq P.x}\\
    \inferrule[Sub-Opaque]{\Sigma;\Gamma\vdash P\cong P'\\ \Sigma;\Gamma\vdash P:\left\{ \overline{S};\overline{D}(x:\star)\overline{D'}\right\}}{\Sigma;\Gamma\vdash P.x \preccurlyeq P'.x}\\
    \inferrule[Sub-BigFunction]{\forall i.\Sigma;\Gamma,X_1:R_1,\ldots, X_{i-1}:R_{i-1}\vdash T_{i}\succcurlyeq R_i\\
      \Sigma;\Gamma,\overline{X_i:R_i}\vdash T'\preccurlyeq R'}{\Sigma;\Gamma\vdash\left(X_i:T_i\right)\to T'\preccurlyeq\left(X_i:R_i\right)\to R'}
  \end{mathpar}
  \caption{Subtyping rules \fbox{$\Sigma;\Gamma\vdash\cap\overline T\preccurlyeq T$}}
\end{figure}
%% \begin{figure}
%%   \centering
%%   \begin{tabular}{c c c c c}
%%     $\kwmdl X : T$ & $\cup$ & $\kwmdl X : T'$ & = & $\kwmdl X : T\cup T'$\\
%%     $\kwclbk X : \bigcap \overline{T}$ & $\cup$ & $\kwclbk X :\bigcap \overline{T'}$ & = & ?\\
%%     $\kwtp x = t$ & $\cup$ & $\kwtp x = t'$ & = & $\kwtp x = t\cup t'$\\
%%     $\kwopq x$ & $\cup$ & $\kwopq x$ & = & $\kwopq x$\\
%%     $\kwopq x$ & $\cup$ & $\kwtp x = t$ & = & $\kwopq x$\\
%%     $\kwtp x = t$ & $\cup$ & $\kwopq x$ & = & $\kwopq x$\\
%%     $D$ & $\cup$ & $D'$ & = & $\epsilon$\\
%%   \end{tabular}
%%   \caption{Component-wise union}
%% \end{figure}

\begin{figure}
  \begin{mathpar}
  \inferrule[Sub-BehBeh]{\overline{\Sigma;\Gamma\vdash t\cong t'}}
    {\Sigma;\Gamma\vdash \BX\left[\overline{x=t}\right]\preccurlyeq \BX\left[\overline{x=t'}\right]}\hfill
  \inferrule[Sub-BehMod]{\\}
    {\Sigma;\Gamma\vdash \BX\left[\overline{x=t}\right]\preccurlyeq \Sigma(\BX)\left(\overline{t}\right)}\\
  \inferrule[Sub-ModBeh]{\overline{t_i=\left\{\overline{D}\right\}_\xi.x_i}\\ \BX\in\xi}
    {\Sigma;\Gamma\vdash\left\{\overline{D}\right\}_\xi\preccurlyeq \BX\left[\overline{x_i=t_i}\right]}\hfill
  \inferrule[Sub-TypeType]{\Sigma;\Gamma\vdash t\cong t'}{[=t]\preccurlyeq[=t']}\hfill
  \inferrule[Sub-TypeOpaque]{\\}{\Sigma;\Gamma\vdash[=t]\preccurlyeq\star}\\
  \inferrule[Sub-ModMod]{\xi'\subseteq\xi\\
    \left\{\overline{D}\right\}\preccurlyeq \left\{\overline{D'}\right\}}
            {\Sigma;\Gamma\vdash\left\{\overline{D}\right\}_\xi\preccurlyeq\left\{\overline{D'}\right\}_{\xi'}}
  \end{mathpar}
  \caption{New subtyping rules}
\end{figure}

\begin{figure}
  \begin{align*}
    \llbracket[=t]\rrbracket &= \text{type}\times\left(\llbracket t\rrbracket\times \llbracket \neg t\rrbracket\right)\\
    \llbracket\star\rrbracket &= \text{type}\times\left(\llbracket \mathbb{1}\rrbracket\times \llbracket \mathbb{1}\rrbracket\right)\\
  \end{align*}
  \caption{Semantic interpretation of the new constructions}
\end{figure}


\section{Optional callbacks}

Explain here how to extend the module system to allow optional callbacks, that is, callbacks that are not required by the behaviour but may be implemented by the module.

\printbibliography
\end{document}

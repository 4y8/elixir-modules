\documentclass[a4paper,10pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{setup}
\usepackage[T1]{fontenc}
\usepackage{mathpartir}
\usepackage[table,dvipsnames]{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{inconsolata}
%\usepackage{libertine}
\usepackage{bbold}

\DeclareMathOperator{\kwdefmt}{\textsf{defmodtype}}
\DeclareMathOperator{\kwend}{\textsf{end}}
\DeclareMathOperator{\kwdo}{\textsf{do}}
\DeclareMathOperator{\kwbvr}{\textsf{\$behaviour}}
\DeclareMathOperator{\kwlet}{\textsf{let}}
\DeclareMathOperator{\kwin}{\textsf{in}}
\DeclareMathOperator{\kwprm}{\textsf{\$param}}
\DeclareMathOperator{\kwdefm}{\textsf{defmodule}}
\DeclareMathOperator{\kwopq}{\textsf{\$opaque}}
\DeclareMathOperator{\kwtp}{\textsf{\$type}}
\DeclareMathOperator{\kwpr}{\textsf{\$private}}
\DeclareMathOperator{\kwmdl}{\textsf{\$module}}
\DeclareMathOperator{\kwclbk}{\textsf{\$callback}}
\DeclareMathOperator{\kwfn}{\textsf{fn}}
\DeclareMathOperator{\kwlike}{\textsf{like}}
\DeclareMathOperator{\kwint}{\textsf{int}}
\DeclareMathOperator{\struct}{\textsf{struct}}
\DeclareMathOperator{\dom}{\textsf{dom}}
\newcommand{\tx}{\textsc{x}}

\author{Aghilas Y. Boussaa}
\sloppy
\begin{document}
An Elixir program is a sequence of module definitions. When a module definition contain a \elix{@callback} declaration, this module is considered a \emph{behaviour}. Behaviours are a kind of hybrid definitions since they may define both a module type and (in case they export functions) a module value. This ambiguity is resolved the compiler, which will generate a module type definition for the behaviour, and a module value definition for the implementation of the behaviour.

For the sake of simplicity, we will suppose that this distinction is already done in the program. In the rest of the document, then, we will suppose that a program is a sequence of module type definitions, followed by the \texttt{Main} module definition, containing just a list of bindings. 
\[\overline{\kwdefmt X \kwdo \overline{P}\, \overline{D} \kwend}\kwdefm \textit{Main} \kwdo \overline{B} \kwend\]
Intuitively, this list of bindings $\overline{B}$ will the list of the toplevel modules definitions of the program, of the form 
\begin{equation}\label{eq:module}
\kwdefm X \kwdo \overline{P}\, \overline{S}\, \overline{B} \kwend
\end{equation}
and every module in the program is then denoted by a unique path starting with \texttt{Main} module name.

The full syntax of the surface language is given in Figure \ref{fig:surfacesyntax}. In Elixir there is a unique syntactic category for names, although it uses the naming convention of using capitalized names for modules and (thus) behaviours. To enhance clarity, we use $x$ to range over expression variables, $X$ for module names, $\tx$ for type names, and $\mathcal X$ for behaviour names. Let us examine in detail the definition of a module, as given in \eqref{eq:module}.

\begin{figure}
  \begin{tabular}{r c ll}
    $\Sigma$ & ::= &$\kwdefmt \mathcal X \kwdo \overline{P}\, \overline{D} \kwend$ \\
    $N$ & ::= & $x$ \\
    & | & $X$ \\
    $S$ & ::= & $\kwbvr \mathcal X$ \\
    $P$ &::= & $\kwprm \tx$ \\
    $B$ &::= & $\kwdefm X \kwdo \overline{P}\, \overline{S}\, \overline{B} \kwend$ \\
    & | & $x = v$\\
    & | & $\kwpr x = v$ \\
    & | & $\kwtp \tx = t$ \\
    & | & $\kwopq \tx = t$ \\
    $M$ & ::= & $X[\overline{\tx=t}]$ \\ 
    & | & $M.M$ \\
    $E$ &::= & $v$ \\
    & | & $x$ \\
    & | & $\kwlet N = E\kwin E$ \\
    & | & $E(\overline{E})$ \\
    & | & $\texttt{\%}\!\left\{\overline{\ell=E}\right\}$ \\
    & | & $E.\ell$ \\
    & | & $(E\in t)?E:E$ \\
    & | & $\textcolor{red}{M.x}$ \\
    & | & $\textcolor{red}{M}$ \\
    $v$ & ::= & $c$ \\
    & | & $\texttt{\%}\!\left\{\overline{\ell=v}\right\}$ \\
    & | & $\$\bigwedge \overline{(\,\overline{\,t\,}\,)\rightarrow t} \kwfn \overline{x} \rightarrow E$ \\
    & | & \textcolor{red}{$\$\bigcap \overline{\left(\overline{N:T}\right)\rightarrow T} \kwfn \overline{N}\rightarrow E$} \\
    $T$ & ::= & $t$ \\
    & | & $\left(\overline{N:T}\right)\rightarrow T$ \\
    & | & $[\overline{\tx:\star}]\to T$ & do we want this syntax or remove it and have $\left\{\overline P;\overline{S};\overline{D}\right\}$\\
    & | & $\left\{\overline{S};\overline{D}\right\}$ \\
    $t$ & ::= & $\kwint$ \\
    & | & $(\overline{\,t\,})\rightarrow t$\\
    & | & $\texttt{\%}\!\left\{\overline{f}\right\}$ \\
    & | & $t\vee t$ \\
    & | & $t\wedge t$ \\
    & | & $\neg t$\\
    & | & $\alpha$ \\
    & | & $\mathbb{O}$ \\
    & | & $\textcolor{red}{M.\tx}$ \\
    & | & $\textcolor{red}{\mathcal{X}\left[\overline{\tx=t}\right]}$ \\
    $D$ & ::= & $\kwmdl X : T$ \\
    & | & $\kwclbk x : \bigcap \overline{T}$ \\
    & | & $\kwopq \tx$ \\
    & | & $\kwtp \tx = t$
  \end{tabular}
  \caption{Syntax of the surface language}\label{fig:surfacesyntax}
\end{figure}


The definition of a module $X$ is a sequence of three blocks: the list $\overline P$ of type parameters of the form $\kwprm \tx$, the list $\overline S$ of behaviours declarations of the form  $\kwbvr \mathcal X$, and the definition of the module itself, which is a sequence of bindings $\overline{B}$. In Elixir, these three blocks may be interleaved, but for the sake of simplicity we will suppose that they are grouped together in the order given above. The module type parameters are used to define the type of the module and are instantiated when the module is used; the list of behaviours specifies the behaviours that this module implements. The bindings $\overline{B}$ are used to define the actual implementation of the module, which may include definitions of values, types, and modules.

A type $t$ is bound to a name $\tx$ which may be transparent or opaque, as defined by the syntax $\kwtp \tx = t$ and $\kwopq \tx =t$ respectively. An opaque type definition make the binding $\tx= t$ visible only inside the module, while a transparent make this binding visible outside the module and is in general used to instantiate the parameters of the behaviours the module implements. Thus for instance if the \elix{StackB} behaviour is parametrized in the type \elix{elem} of its element, a module \elix{StackInt} implementing the behaviour for integers will be defined as
\begin{minted}{elixir}
defmodule StackInt do
  !\tp!behaviour StackB
  !\tp!type elem = integer()
  !\tp!opaque stack = list(integer())

  !\tp! () -> stack
  def new = fn() -> [] end

  !\tp! (stack, elem) -> stack
  def push = fn(s, e) -> [e|s] end

  !\tp! (stack) -> {integer(),stack}
  def pop = fn(s) -> {hd(s), tl(s)}
end
\end{minted}
Of course we can also define the module stack to be parametric in the type of
its elements, and then pass this parameter as argument of the behaviour, as in
the following example, in which we replace \elix{pop} by \elix{top} and we add a
higher-order function
\begin{minted}{elixir}
defmodule StackModule do
  !\tp!param elem
  !\tp!behaviour StackB
  !\tp!type elem = elem
  !\tp!opaque stack = list(elem)

  !\tp! () -> stack
  def new = fn() -> [] end

  !\tp! (stack, elem) -> stack
  def push = fn(s, e) -> [e|s] end

  !\tp! (stack) -> elem
  def top = fn(s) -> hd(s) end

  !\tp! (X: StackB[elem=elem], sx: X.stack, Y: StackB[elem=elem], sy: Y.stack) -> Y.stack
  def move (X, sx, Y, sy) do Y.push(sy,X.top(sx)) end
\end{minted}
A value $v$ is bound to a name $x$ which may be exported or private, as defined by the syntax $x = v$ and $\kwpr x = v$ respectively. In general a value $v$ is either a constant or a function. In the latter case the function is defined in Elixir by the syntax \elix{def} and \elix{defp} for exported and private functions respectively, and prefixed by their type annotations as in the following example:
\begin{minted}{elixir}
defmodule X do
  !\tp! (!$t_1$! -> !$t_2$!) and (!$t_3$! -> !$t_4$!)
  def f(x,y) do !$E_1$! end

  !\tp! (X : StackModule[elem=integer()], s: X.stack) -> integer()
  defp g(X,s) do !$E_2$! end
end  
\end{minted}
The above examples are considered as syntactic sugar and in the syntax of Figure \ref{fig:surfacesyntax} are rendered the following definitions 
\begin{minted}{elixir}
defmodule X do
  f = !\tp$(t_1\to t_2) \wedge (t_3 \to t_4)$! fn x, y -> !$E_1$!
  g = private !\tp!(X : Stack[elem=integer()], s: X.stack) !$\to$! integer() fn X, s -> !$E_2$!
end
\end{minted}

A module has a type 


\begin{figure}
  \begin{tabular}{r c ll}
     $B$ &::= &  $\!\!X = \textsf{fn}(\overline{\tx:\star})\to \{\overline{B}\}_{\overline{\mathcal{X}}}$ &\color{gray} module $X$ with parameters $\overline x$ implementing $\overline{\mathcal X}$\\
    & | & $x = v$                                   &\color{gray} exported definition \\
    & | & $x = \textsf{private }v$                  &\color{gray} private definition\\
    & | & $\tx = \textsf{type }t$                     &\color{gray} transparent type or behaviour argument\\
    & | & $\tx = \textsf{opaque }t$                   &\color{gray} opaque type\\[3mm]
    $M$ & ::= & $X[\overline{\tx=t}]$                 &\color{gray} local module\\
    & | & $M.M$                                     &\color{gray} imported module\\[3mm]
    $N$ & ::= & $x$ \\
    & | & $X$ \\[3mm]
   $E$ &::= & $v$ \\
    & | & $x$ \\
    & | & $\kwlet N = E\kwin E$ \\
    & | & $E(\overline{N})$ \\
    & | & $\texttt{\%}\!\left\{\overline{\ell=E}\right\}$ \\
    & | & $E.\ell$ \\
    & | & $(E\in t)?E:E$ \\
    & | & {\color{red}\text{$M.x$}} \\
    & | & {\color{red}\text{$M$}} \\
    $v$ & ::= & $c$ \\
    & | & $\texttt{\%}\!\left\{\overline{\ell=v}\right\}$ \\
    & | & $\$\bigwedge \overline{(\,\overline{t}\,)\rightarrow t} \kwfn \overline{x} \rightarrow E$ \\
    & | & {\color{red} \text{$\$\bigcap \overline{\left(\overline{N:T}\right)\rightarrow T} \kwfn \overline{N}\rightarrow E$}} \\[3mm]
    $T$ & ::= & $t$ \\
    & | & $\left(\overline{N:T}\right)\rightarrow T$ \\
    & | & $\left\{\overline{D}\right\}_{\overline{\mathcal X}}$ \\
    & | & $(\overline{\tx:\star})\to T$        & \text{we can include this case in the above by adding $\star$ to $T$ and $\tx$ to $N$} \\
    & | & $\star$ &\text{\small I would remove it: we do not want to pass around modules unless}\\
                  &&&\text{\small they are fully instantiated} $f(X:(\tx:\star)\to ...)\to ...X[\tx=\textsf{int}] ...$\\
    $t$ & ::= & $\kwint$ \\
    & | & $(\overline{\,t\,})\rightarrow t$\\
    & | & $\texttt{\%}\!\left\{\overline{f}\right\}$ \\
    & | & $t\vee t$ \\
    & | & $t\wedge t$ \\
    & | & $\neg t$\\
    & | & $\alpha$ \\
    & | & $\mathbb{O}$ \\
    & | & \textcolor{red}{\text{$M.\tx$}}                          &\color{gray} the type $x$ imported from module $M$\\
    & | & \textcolor{red}{\text{$\mathcal{X}[\overline{\tx=t}]$}}  &\color{gray} a behaviour\\[3mm]
    $D$ & ::= & $X : T$                               &\color{gray} exports a module $X$ of type $T$\\
    & | & $x : \bigcap \overline{T}$                  &\color{gray} exports a value $x$ of type $\bigcap\overline T$ \\
    & | & $\tx : \star$                                 &\color{gray} exports an opaque type $x$\\  
    & | & $\tx : [=t]$                                  &\color{gray} exports a transparent type $x = t$  \\[3mm]
  \end{tabular}

 where $\mathcal X$ ranges over behaviour names, $X$ over module names, $x$ over variable names, and $\ell$ over map keys. 
  \caption{Syntax of the surface language}
\end{figure}

\begin{figure}
  \begin{tabular}{r c l}
    $\tau$ & ::= & $t$ \\
    & | & $\star$ \\
    & | & $\left(\overline{N:\tau}\right)\rightarrow \tau$ \\
    & | & $\kwlike\left(\overline{X\left[\overline{x=t}\right].}X\left[\overline{x=t}\right]\right)$ \\
    & | & $\cap\overline{\tau}$\\
    & | & $X\left[\overline{x=t}\right]$
  \end{tabular}
  \caption{Syntax of surface module types}
\end{figure}
%\begin{figure}
%  \centering
%  \begin{tabular}{c c c c c}
%    $\kwmdl X : T$ & $\cap$ & $\kwmdl X : T'$ & = & $\kwmdl X : T\cap T'$\\
%    $\kwclbk X :\bigcap\overline{T}$ & $\cap$ & $\kwclbk X : \bigcap\overline{T'}$ & = & $\kwclbk X : \bigcap \overline{T}\,\overline{T'}$\\
%    $\kwtp x = t$ & $\cap$ & $\kwtp x = t'$ & = & $\kwtp x = t\wedge t'$\\
%    $\kwopq x$ & $\cap$ & $\kwopq x$ & = & $\kwopq x$\\
%    $\kwopq x$ & $\cap$ & $\kwtp x = t$ & = & $\kwtp x = t$\\
%    $\kwtp x = t$ & $\cap$ & $\kwopq x$ & = & $\kwtp x = t$\\
%    $D$ & $\cap$ & $D'$ & = & $\epsilon$\\
%  \end{tabular}
%  \caption{Component-wise intersection}
%\end{figure}
\begin{figure}
  \begin{mathpar}
    \inferrule[ElEnv-Empty]{\\}{\Sigma;\Gamma\vdash\epsilon}\hfill
    \inferrule[ElEnv-Expr]{\Sigma;\Gamma\vdash t:\star}{\Sigma,\Gamma\vdash x:t,\Gamma}\hfill
    \inferrule[ElEnv-Type]{\Sigma;\Gamma\vdash t:\star}{\Sigma;\Gamma\vdash x=t,\Gamma}\\
    \inferrule[ModEnv-ModuleType]
      {\Sigma;\Gamma,\overline{x:\star}\vdash\left\{\overline{D}\right\}}
      {\Sigma;\Gamma\vdash X=\overline{x}\mapsto\overline{D},\Sigma}\hfill
    \inferrule[ModEnv-Empty]{\\}{\Sigma;\Gamma\vdash\epsilon}\hfill
    \inferrule[ModEnv-Module]
      {\Sigma;\Gamma,\overline{x:\star}\vdash\left\{;\overline{B}\right\}}
      {\Sigma;\Gamma\vdash X=\overline{x}\mapsto\overline{B},\Sigma}\\
  \end{mathpar}
  \caption{Formation rules for environments}
\end{figure}
\begin{figure}
  \begin{mathpar}
    \inferrule[EqPath-Empty]{\\}{\Sigma;\Gamma\vdash\epsilon\cong\epsilon}\hfill
    \inferrule[EqPath-Add]
      {\Sigma;\Gamma\vdash P_1\cong P_2\\\forall i.\Sigma,\Gamma\vdash t_i\cong t'_i}
      {\Sigma;\Gamma\vdash P_1.X\left[\overline{x_i=t_i}\right] \cong
        P_2.X\left[\overline{x_i=t'_i}\right]}\\
  \end{mathpar}
  \caption{Rules for path equivalence}
\end{figure}
\begin{figure}
  \begin{mathpar}
      \inferrule[WF-Behave]{\Sigma;\Gamma\vdash X :
        \overline{x:\star}\to \{D\} \\ \Sigma;\Gamma\vdash t_i:\star}
                {\Sigma;\Gamma\vdash X[\overline{x_i=t_i}]}
                
    \inferrule[WF-Field]{\Sigma;\Gamma\vdash P :
      \left\{\kwtp x = t\right\}\cup
      \left\{\kwopq x\right\}}
              {\Sigma;\Gamma\vdash P.x}\hfill
    \inferrule[WF-Star]{\Sigma;\Gamma\vdash}
              {\Sigma;\Gamma\vdash\star}\\
    \inferrule[WF-Function]{\Sigma;\Gamma\vdash\\
    \forall 0\leq j\leq n.\Sigma;\Gamma,\overline{N_i:T_i}^{i=1,\ldots,j}\vdash T_{j+1}}
              {\Sigma;\Gamma\vdash \left(\overline{N_i:T_i}^{i=1,\ldots,n}\right)\to T_{n+1}}\\
    \inferrule[WF-ModuleTypeNames]{\forall S_i\in\overline{S}.\Sigma(S_i)=\overline{x:\star}^i\mapsto \overline{D}^i\\
      \left\{\overline{D}\right\} \preccurlyeq
        \left\{\overline{\overline{x:[=\_]}^i\;\overline{D}^i}\right\}\\
    \forall i\neq
    j.(\dom\left(\overline{D}^i\right)\#\dom\left(\overline{D}^j\right)\text{
      and } \overline{x}^i\#\overline{x}^j)\\
    \Sigma;\Gamma\vdash\left\{\overline{D}\right\}}
              {\Sigma;\Gamma\vdash\left\{\overline{S};\overline{D}\right\}}\left(S\neq\epsilon\right)\\
    \inferrule[WF-ModuleTypeModule]{\Sigma;\Gamma\vdash T\\\Sigma;\Gamma,X:T\vdash\left\{\overline{D}\right\}}
              {\Sigma;\Gamma\vdash\left\{(\kwmdl X:T)\overline{D}\right\}}\hfill
    \inferrule[WF-ModuleTypeOpaque]{\Sigma;\Gamma,x:\star\vdash\left\{\overline{D}\right\}}
              {\Sigma;\Gamma\vdash\left\{(\kwopq x)\overline{D}\right\}}\\
    \inferrule[WF-ModuleTypeType]{\Sigma;\Gamma\vdash t\\\Sigma;\Gamma,x:[=t]\vdash\left\{\overline{D}\right\}}
              {\Sigma;\Gamma\vdash\left\{(\kwtp x = t)\overline{D}\right\}}\hfill
    \inferrule[WF-ModuleTypeCallback]{\overline{\Sigma;\Gamma\vdash T}\\\Sigma;\Gamma,x:\bigcap\overline{T}\vdash\left\{\overline{D}\right\}}
              {\Sigma;\Gamma\vdash\left\{(\kwclbk x:\bigcap\overline{T})\overline{D}\right\}}
  \end{mathpar}
  \caption{Well-formedness rules for types \fbox{$\Sigma;\Gamma\vdash T$}}
\end{figure}
\begin{figure}
  \begin{mathpar}
    \inferrule[Bind-DefModule]
       {\Sigma; \Gamma,\overline{P:\star}\vdash\overline{B}:\overline{D}\\
        \Sigma; \Gamma,X:\left(\overline{P:\star}\right)\rightarrow
        \left\{\overline{S};\overline{D}\right\}\vdash
        \overline{B_0}:\overline{D_0}}
       {\Sigma; \Gamma\vdash\left(\kwdefm X\kwdo \overline{P}\overline{S}\overline{B}
        \kwend\right) \overline{B_0}:\left(X:\left(\overline{P:\star}\right)\rightarrow
        \left\{\overline{S};\overline{D}\right\}\right)\overline{D_0}}\\
    \inferrule[Bind-Type]
       {\Sigma;\Gamma\vdash t:\star\\
        \Sigma;\Gamma, x:[=t]\vdash\overline{B}:\overline{D}}
       {\Sigma;\Gamma\vdash\left(\kwtp x=t\right)\overline{B}: \left(x :[=t]\right)\overline{D}}\\
    \inferrule[Bind-Opaque]
       {\Sigma;\Gamma\vdash t:\star\\
        \Sigma;\Gamma, x:[=t]\vdash\overline{B}:\overline{D}}
       {\Sigma;\Gamma\vdash\left(\kwopq x = t\right)\overline{B}:  \left(x:\star\right)\overline{D}}\\
    \inferrule[Bind-Empty]
       {\\}{\Sigma;\Gamma\vdash\epsilon:\epsilon}\hfill
    \inferrule[Bind-Value]
       {\Sigma;\Gamma\vdash v:\cap\overline{T}\\
        \Sigma;\Gamma,x:\cap\overline{T}\vdash\overline{B}:\overline{D}}
       {\Sigma;\Gamma\vdash\left(x=v\right)\overline{B}:
        \left(x:\cap\overline{T}\right)\overline{D}}
  \end{mathpar}
  \caption{Typing rules for bindings \fbox{$\Sigma;\Gamma\vdash\overline{B}:\overline{D}$}}
\end{figure}
\begin{figure}
  \begin{mathpar}
    \inferrule[Path-Empty]{\\}{\Sigma;\Gamma\vdash\epsilon:\{\epsilon;\Gamma\}}\\
    \inferrule[Path-SubModule]{\Sigma;\Gamma\vdash P:\left\{\_;\overline{D}\right\}\\
      \overline{D} = \ldots, \kwdefm X\kwdo\overline{P}\overline{S} \overline{B} \kwend ,\ldots \\
      \overline{P} = \overline{\kwprm x}\\
      \Sigma;\Gamma\vdash\overline{t}
    }{\Sigma;\Gamma\vdash P.X\left[\overline{x=t}\right]:\left\{\overline{S} ; \overline{\kwtp x=t}\, \overline{B} \right\}}
  \end{mathpar}
  \caption{Well-formdness rules for paths}
\end{figure}
\begin{figure}
  \begin{mathpar}
    \inferrule[Type-Variable]{\Sigma;\Gamma\vdash P:\left\{\overline{S};\overline{D} (x:\cap T)\overline{D'}\right\}}{\Sigma;\Gamma\vdash P.x : \cap T}\\
    \inferrule[Type-Subsumption]{\Sigma;\Gamma\vdash T\\ \Sigma;\Gamma\vdash E : \cap\overline{T'}\\ \Sigma;\Gamma\vdash\cap\overline{T'}\preccurlyeq T}{\Sigma;\Gamma\vdash E : T}
    \\
    \inferrule[Type-BigFunction]
        {\Sigma;\Gamma\vdash\cap\overline{\overline{N:T}\to T'} \and \overline{\Sigma;\Gamma,\overline{N:T}}\vdash E:T'}
        {\Sigma;\Gamma\vdash\$\cap\overline{\forall\overline{\alpha}\left(\overline{N:T}\right)\to T'}\kwfn \overline{N}\to E:\cap\overline{\overline{N:T}\to T'}}\\
    \inferrule[Type-Module]{\Sigma;\Gamma\vdash P:\left\{\overline{S_0};\overline{D_0}
      (X:\overline{y:\star}\to\left\{\overline{S};\overline{D}\right\})
      \overline{D_1}\right\}\\
      \Sigma;\Gamma\vdash\overline{t}\\
      \overline{x}\simeq\overline{y}
    }{\Sigma;\Gamma\vdash P.X\left[\overline{x=t}\right]:\left\{\overline{S};\overline{D}\right\}}
  \end{mathpar}
  \caption{Typing rules for the surface language}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \inferrule[Sub-StarRefl]{\\}{\star\preccurlyeq\star}\hfill
    \inferrule[Sub-Elixir]{t\preccurlyeq t'}{\Sigma;\Gamma\vdash t\preccurlyeq t'}\hfill
    \inferrule[Sub-Intersection]{\exists i\in I, T_i\preccurlyeq T}{\Sigma;\Gamma\vdash\cap_I\overline{T_i}\preccurlyeq T}\\
    \inferrule[Sub-ModuleLeft]{\Sigma;\Gamma\vdash P:\left\{\overline{S};\overline{D} (x:[=t])\overline{D'}\right\}\\ \Sigma;\Gamma\vdash t\preccurlyeq T}{\Sigma;\Gamma\vdash P.x\preccurlyeq T}\\
    \inferrule[Sub-ModuleRight]{\Sigma;\Gamma\vdash P:\left\{\overline{S};\overline{D} (x:[=t])\overline{D'}\right\}\\ \Sigma;\Gamma\vdash \cap\overline{T}\preccurlyeq t}{\Sigma;\Gamma\vdash\cap\overline{T}\preccurlyeq P.x}\\
    \inferrule[Sub-Opaque]{\Sigma;\Gamma\vdash P\cong P'\\ \Sigma;\Gamma\vdash P:\left\{ \overline{S};\overline{D}(x:\star)\overline{D'}\right\}}{\Sigma;\Gamma\vdash P.x \preccurlyeq P'.x}\\
    \inferrule[Sub-BigFunction]{\forall i.\Sigma;\Gamma,X_1:R_1,\ldots, X_{i-1}:R_{i-1}\vdash T_{i}\succcurlyeq R_i\\
      \Sigma;\Gamma,\overline{X_i:R_i}\vdash T'\preccurlyeq R'}{\Sigma;\Gamma\vdash\left(X_i:T_i\right)\to T'\preccurlyeq\left(X_i:R_i\right)\to R'}
  \end{mathpar}
  \caption{Subtyping rules \fbox{$\Sigma;\Gamma\vdash\cap\overline T\preccurlyeq T$}}
\end{figure}
%% \begin{figure}
%%   \centering
%%   \begin{tabular}{c c c c c}
%%     $\kwmdl X : T$ & $\cup$ & $\kwmdl X : T'$ & = & $\kwmdl X : T\cup T'$\\
%%     $\kwclbk X : \bigcap \overline{T}$ & $\cup$ & $\kwclbk X :\bigcap \overline{T'}$ & = & ?\\
%%     $\kwtp x = t$ & $\cup$ & $\kwtp x = t'$ & = & $\kwtp x = t\cup t'$\\
%%     $\kwopq x$ & $\cup$ & $\kwopq x$ & = & $\kwopq x$\\
%%     $\kwopq x$ & $\cup$ & $\kwtp x = t$ & = & $\kwopq x$\\
%%     $\kwtp x = t$ & $\cup$ & $\kwopq x$ & = & $\kwopq x$\\
%%     $D$ & $\cup$ & $D'$ & = & $\epsilon$\\
%%   \end{tabular}
%%   \caption{Component-wise union}
%% \end{figure}

\begin{figure}
  \begin{mathpar}
  \inferrule[Sub-BehBeh]{\overline{\Sigma;\Gamma\vdash t\cong t'}}
    {\Sigma;\Gamma\vdash X\left[\overline{x=t}\right]\preccurlyeq X\left[\overline{x=t'}\right]}\hfill
  \inferrule[Sub-BehMod]{\\}
    {\Sigma;\Gamma\vdash X\left[\overline{x=t}\right]\preccurlyeq \Sigma(X)\left(\overline{t}\right)}\\
  \inferrule[Sub-ModBeh]{\overline{t_i=\left\{\overline{D}\right\}_\xi.x_i}\\ X\in\xi}
    {\Sigma;\Gamma\vdash\left\{\overline{D}\right\}_\xi\preccurlyeq X\left[\overline{x_i=t_i}\right]}\hfill
  \inferrule[Sub-TypeType]{\Sigma;\Gamma\vdash t\cong t'}{[=t]\preccurlyeq[=t']}\hfill
  \inferrule[Sub-TypeOpaque]{\\}{\Sigma;\Gamma\vdash[=t]\preccurlyeq\star}\\
  \inferrule[Sub-ModMod]{\xi'\subseteq\xi\\
    \left\{\overline{D}\right\}\preccurlyeq \left\{\overline{D'}\right\}}
            {\Sigma;\Gamma\vdash\left\{\overline{D}\right\}_\xi\preccurlyeq\left\{\overline{D'}\right\}_{\xi'}}
  \end{mathpar}
  \caption{New subtyping rules}
\end{figure}

\begin{figure}
  \begin{align*}
    \llbracket[=t]\rrbracket &= \text{type}\times\left(\llbracket t\rrbracket\times \llbracket \neg t\rrbracket\right)\\
    \llbracket\star\rrbracket &= \text{type}\times\left(\llbracket \mathbb{1}\rrbracket\times \llbracket \mathbb{1}\rrbracket\right)\\
  \end{align*}
  \caption{Semantic interpretation of the new constructions}
\end{figure}

\end{document}
